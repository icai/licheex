{"version":3,"sources":["index.js","utils/is.js","emitter.js","innerPlugins.js","logger.js","mapGettersToState.js","wrapDataInstance.js","utils/manipulate.js","libs/immutability-helper-enhanced/index.js","libs/immer/index.js","global.js","utils/wrapState.js","createHelpers.js","dataTransform.js","connect.js","mapHelpersToMethod.js","provider.js","storeConfigPreHandle.js","mixins/default.js","Watcher.js","utils/obj.js","Observer.js","polyfill/index.js","polyfill/array.prototype.find.js","polyfill/array.prototype.findIndex.js","polyfill/array.prototype.includes.js","polyfill/string.prototype.includes.js","polyfill/string.prototype.startsWith.js","polyfill/proxy.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,ACHA,AHSA;ACFA,AFMA,AGTA,ACHA,AHSA;ACFA,AFMA,AGTA,ACHA,AHSA;ACFA,AFMA,AIZA,ACHA,AJYA;ACFA,AFMA,AIZA,ACHA,AJYA;ACFA,AFMA,AIZA,ACHA,AJYA;ACFA,AFMA,AIZA,ACHA,AJYA,AKfA;AJaA,AFMA,AIZA,ACHA,AJYA,AKfA;AJaA,AFMA,AIZA,ACHA,AJYA,AKfA;AJaA,AFMA,AIZA,ACHA,AJYA,AMlBA,ADGA;AJaA,AFMA,AIZA,ACHA,AJYA,AMlBA,ADGA;AJaA,AFMA,AIZA,ACHA,AJYA,AMlBA,ADGA;AJaA,AFMA,AQxBA,AJYA,ACHA,AJYA,AMlBA,ADGA;AJaA,AFMA,AQxBA,AJYA,ACHA,AJYA,AMlBA,ADGA;AJaA,AFMA,AQxBA,AJYA,ACHA,AJYA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,ACHA,AJYA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,ACHA,AJYA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,ACHA,AJYA,AMlBA,ADGA;AJaA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,ADGA;AJaA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,ADGA;AJaA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,ADGA;AJaA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AJaA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AJaA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AMjBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AMjBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AMjBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AMjBA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AMjBA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AMjBA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AJYA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AU9BA,Ad0CA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AU9BA,Ad0CA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AU9BA,Ad0CA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AHSA,AU9BA,ACHA,Af6CA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,ACHA,Af6CA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,ACHA,Af6CA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,ACHA,ACHA,AhBgDA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,ACHA,ACHA,AhBgDA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,ACHA,ACHA,AhBgDA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,AIZA,ALeA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,ADGA;AQvBA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,ADGA;AatCA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,ADGA;AatCA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,ADGA;AatCA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,ADGA;AatCA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,AavCA,Ad0CA;AatCA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,AavCA,Ad0CA;AatCA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AFMA,ACHA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AIZA,ANkBA,ACHA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AIZA,ANkBA,ACHA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AIZA,ANkBA,ACHA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AKfA,ADGA,ANkBA,ACHA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AKfA,ADGA,ANkBA,ACHA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AKfA,ADGA,ALeA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AKfA,ACHA,AFMA,ALeA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AKfA,ACHA,APqBA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AKfA,ACHA,APqBA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AKfA,ACHA,ACHA,ARwBA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AKfA,ACHA,ACHA,ARwBA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AGTA,AKfA,ACHA,ACHA,ARwBA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,ACHA,AT2BA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,ACHA,AT2BA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,ACHA,AT2BA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,ACHA,ACHA,AV8BA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,ACHA,ACHA,AV8BA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,ACHA,ACHA,AV8BA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AFMA,ACHA,AV8BA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AFMA,ACHA,AV8BA,AhBgDA,AMlBA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AFMA,ACHA,AV8BA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AFMA,AT2BA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AFMA,AT2BA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AFMA,AT2BA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AFMA,AT2BA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AFMA,AT2BA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AFMA,AT2BA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,ACHA,AXiCA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AFMA,AT2BA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AXiCA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AXiCA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AXiCA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AXiCA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AXiCA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AXiCA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AXiCA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AXiCA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AXiCA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,AXiCA,AV8BA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AQxBA,ACHA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AOrBA,AS3BA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AgBhDA,ACHA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AiBnDA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AiBnDA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AiBnDA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AiBnDA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AiBnDA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AiBnDA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AiBnDA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AiBnDA,AGTA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,ALeA,AFMA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA,AavCA;ACFA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AQxBA,AV8BA,AS3BA,ADGA,AoB5DA,ArB+DA;AczCA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AFMA,APqBA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AT2BA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AT2BA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AT2BA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AT2BA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AT2BA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;APsBA,AT2BA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AV8BA,AFMA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA,AoB5DA;AhBiDA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AZoCA,AS3BA,ADGA;AIXA,AHSA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('./utils/is');var isString = __TEMP__['isString'];var isArray = __TEMP__['isArray'];var isFunc = __TEMP__['isFunc'];\nvar __TEMP__ = require('./emitter');var EventEmitter = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./innerPlugins');var _innerPlugins = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./mapGettersToState');var mapGettersToState = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./createHelpers');var createHelpers = __REQUIRE_DEFAULT__(__TEMP__);var createConnectHelpers = __TEMP__['createConnectHelpers'];\nvar __TEMP__ = require('./dataTransform');var setDataByStateProps = __TEMP__['setDataByStateProps'];var setStoreDataByState = __TEMP__['setStoreDataByState'];\nvar __TEMP__ = require('./wrapDataInstance');var wrapDataInstance = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./global');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./connect');var connect = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./provider');var GlobalStore = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./mapHelpersToMethod');var mapActionsToMethod = __TEMP__['mapActionsToMethod'];var mapMutationsToMethod = __TEMP__['mapMutationsToMethod'];\nvar __TEMP__ = require('./storeConfigPreHandle');var configPreHandler = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./utils/wrapState');var wrapState = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./mixins/default');var defaultMixin = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./Watcher');var Watcher = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./polyfill/index');\n\nfunction getPath(link) {\n  return isString(link) && link.split('/')[1];\n}\n\nclass Store {\n  constructor(store, options) {\n    this.$global = global;\n    this.$emitter = new EventEmitter();\n    // 预处理配置转化\n    configPreHandler(store);\n    Object.assign(this, {\n      connectGlobal: store.connectGlobal,\n      mapGlobals: store.mapGlobals,\n      actions: store.actions,\n      methods: store.methods || {},\n      mutations: store.mutations || {},\n      plugins: store.plugins || [],\n      getters: store.getters || {},\n      instanceName: store.namespace || store.instanceName\n    });\n    //@todo  微信小程序不支持，需要转换成 $watch\n    this.stateConfig = mapGettersToState(store.state || {}, this.getters, this);\n    this.stateConfig.$global = this.connectGlobal ? global.getGlobalState(this.mapGlobals) : {};\n    this.subscribe = this.subscribe.bind(this);\n    this.register = this.register.bind(this);\n    this.subscribeAction = this.subscribeAction.bind(this);\n    this.when = this.when.bind(this);\n    this.watch = this.watch.bind(this);\n  }\n  getInstance() {\n    return this.storeInstance;\n  }\n  watch(predicate, effect) {\n    this.when(predicate, effect, true);\n  }\n  // 实现 mobx when\n  when (predicate, effect, isWatch) {\n    const emitter = this.$emitter;\n    if (!predicate) return Promise.reject();\n    return new Promise((resolve) => {\n      const initialData = this.storeInstance ? this.storeInstance.data : {};\n      if (predicate(initialData)) {\n        if (effect) {\n          effect.call(this, initialData);\n        }\n        return resolve(initialData);\n      }\n      const dispose = emitter.addListener('updateState', ({ state, mutation, prevState }) => {\n        const newData = setStoreDataByState(this.storeInstance.data, state);\n        const currentPageInstance = getCurrentPages().pop() || {};\n        const instanceView = this.storeInstance.$viewId || -1;\n        const currentView = currentPageInstance.$viewId || -1;\n        // 已经不在当前页面的不再触发\n        if (instanceView === currentView) {\n          if (predicate(newData)) {\n            dispose();\n            if (effect) {\n              effect.call(this, newData);\n            }\n            resolve(newData);\n          }\n        }\n      });\n    });\n  }\n  // 实现 store.subscribe\n  subscribe (subscriber, actionSubscriber) {\n    const emitter = this.$emitter;\n    const originViewInstance = getCurrentPages().pop() || {};\n    if (subscriber) {\n      this.storeUpdateLisitenerDispose = emitter.addListener('updateState', ({ state, mutation, prevState }) => {\n        const currentPageInstance = getCurrentPages().pop() || {};\n        const instanceView = originViewInstance.$viewId || -1;\n        const currentView = currentPageInstance.$viewId || -1;\n        // 已经不在当前页面的不再触发\n        if (instanceView === currentView) {\n          subscriber(mutation, wrapState({ ...this.storeInstance.data }), wrapState({ ...prevState }));\n        }\n      });\n    }\n    if (actionSubscriber) {\n      this.storeDispatchActionLisitenerDispose = emitter.addListener('dispatchAction', (action, next) => {\n        actionSubscriber(action, next);\n      });\n    }\n  };\n  subscribeAction(actionSubscriber) {\n    const emitter = this.$emitter;\n    const originViewInstance = getCurrentPages().pop() || {};\n    if (actionSubscriber) {\n      emitter.addListener('dispatchAction', (action, next) => {\n        const currentPageInstance = getCurrentPages().pop() || {};\n        const instanceView = originViewInstance.$viewId || -1;\n        const currentView = currentPageInstance.$viewId || -1;\n        if (instanceView === currentView) {\n          return actionSubscriber(action, next);\n        }\n      });\n    }\n  }\n  use(option = defaultMixin) {\n    if (isFunc(option)) {\n      return option.call(this, this.register, global);\n    } else {\n      return this.register(option);\n    }\n  }\n  register(config = {}) {\n    const that = this;\n    config.data = config.data || {};\n    // 初始化数据\n    // @todo 不能直接复制，需求区分处理\n    Object.assign(config.data, this.stateConfig, config.state);\n\n    const initialState = { ...config.data };\n    const originOnLoad = config.onLoad;\n    const originOnUnload = config.onUnload;\n    const originOnShow = config.onShow;\n    const originOnHide = config.onHide;\n    const emitter = this.$emitter;\n    // mappers\n    if (config.mapActionsToMethod) {\n      mapActionsToMethod(config.mapActionsToMethod, this.actions, config);\n    }\n    if (config.methods) {\n      mapMutationsToMethod(config.methods, config);\n    }\n    if (config.mapMutationsToMethod) {\n      mapMutationsToMethod(config.mapMutationsToMethod, config);\n    }\n    config.onHide = function() {\n      const currentPageInstance = getCurrentPages().pop() || {};\n      global.emitter.emitEvent('updateCurrentPath', {\n        from: getPath(currentPageInstance.route),\n        fromViewId: currentPageInstance.$viewId || -1\n      });\n      originOnHide && originOnHide.apply(this, arguments);\n      this._isHided = true;\n    };\n    config.onUnload = function() {\n      const currentPageInstance = getCurrentPages().pop() || {};\n      global.emitter.emitEvent('updateCurrentPath', {\n        from: getPath(currentPageInstance.route)\n      });\n      this.licheexUpdateLisitener && this.licheexUpdateLisitener();\n      this.licheexUpdateLisitenerGlobal && this.licheexUpdateLisitenerGlobal();\n      if (this.$store) {\n        this.$store.storeUpdateLisitenerDispose && this.$store.storeUpdateLisitenerDispose();\n        this.$store.storeDispatchActionLisitenerDispose && this.$store.storeDispatchActionLisitenerDispose();\n      }\n      originOnUnload && originOnUnload.apply(this, arguments);\n    };\n    config.onShow = function(d) {\n      const currentPageInstance = getCurrentPages().pop() || {};\n      // 消费 Resume 字段\n      const resumeData = global.messageManager.pop('$RESUME') || {};\n      global.emitter.emitEvent('updateCurrentPath', Object.assign(currentPageInstance.$routeConfig || {}, {\n        currentPath: getPath(currentPageInstance.route),\n        context: resumeData\n      }));\n      // 如果有开全局，先触发\n      if (that.connectGlobal) {\n        // sync global data\n        emitter.emitEvent('updateState', {\n          state: {\n            ...this.data,\n            $global: {\n              ...this.data.$global,\n              ...global.getGlobalState(this.mapGlobals)\n            }\n          },\n          mutation: {\n            type: 'sync_global_data'\n          },\n          prevState: this.data\n        });\n      }\n      originOnShow && originOnShow.apply(this, arguments);\n      if (this._isHided) {\n        config.onResume && config.onResume.call(this, Object.assign({}, d, resumeData));\n        this._isHided = false;\n      }\n    };\n    config.onLoad = function(query) {\n      const onloadInstance = this;\n      this.$emitter = emitter;\n      this.$globalEmitter = global.emitter;\n      this.$message = global.messageManager;\n      this.$store = that;\n      this.$when = that.when;\n\n      if (!this.__watcher || !(this.__watcher instanceof Watcher)) {\n        this.__watcher = new Watcher(this);\n      }\n        // 先榜上更新 store 的 监听器\n      this.licheexUpdateLisitener = emitter.addListener('updateState', ({ state }) => {\n        const newData = setStoreDataByState(this.data, state);\n        const currentPageInstance = getCurrentPages().pop() || {};\n        const instanceView = onloadInstance.$viewId || -1;\n        const currentView = currentPageInstance.$viewId || -1;\n        // 已经不在当前页面的不再触发\n        if (instanceView === currentView) {\n          this.setData(newData);\n        }\n      });\n      if (that.connectGlobal) {\n       // 立马触发同步\n        emitter.emitEvent('updateState', {\n          state: {\n            ...this.data,\n            $global: {\n              ...this.data.$global,\n              ...global.getGlobalState(this.mapGlobals)\n            }\n          },\n          mutation: {\n            type: 'sync_global_data'\n          },\n          prevState: this.data\n        });\n\n        // 增加nextprops的关联\n        this.licheexUpdateLisitenerGlobal = global.emitter.addListener('updateGlobalStore', () => {\n          const currentPageInstance = getCurrentPages().pop() || {};\n          const instanceView = onloadInstance.$viewId || -1;\n          const currentView = currentPageInstance.$viewId || -1;\n          // 已经不在当前页面的不再触发\n          if (instanceView !== currentView) return;\n          emitter.emitEvent('updateState', {\n            state: {\n              ...this.data,\n              $global: {\n                ...this.data.$global,\n                ...global.getGlobalState(this.mapGlobals)\n              }\n            },\n            mutation: {\n              type: 'sync_global_data'\n            },\n            prevState: this.data\n          });\n        });\n      }\n      this.subscribe = that.subscribe;\n      this.subscribeAction = that.subscribeAction;\n      // 设置页面 path 和 query\n      const currentPageInstance = getCurrentPages().pop() || {};\n      const currentPath = getPath(currentPageInstance.route);\n      // 外面携带的数据\n      const contextData = global.messageManager.pop('$RESUME') || {};\n      const viewId = currentPageInstance.$viewId || -1;\n      this.$routeConfig = {\n        currentPath,\n        query,\n        context: contextData,\n        viewId\n      };\n      global.emitter.emitEvent('updateCurrentPath', this.$routeConfig);\n      // query.$context = loadData;\n      that.storeInstance = this;\n      const name = that.instanceName || currentPath || viewId || -1;\n      // 把命名空间灌到实例\n      this.instanceName = name;\n      global.registerInstance(name, {\n        config: { actions: that.actions, mutations: that.mutations, state: initialState },\n        store: that,\n        name,\n        currentPath,\n        viewId\n      });\n      if (that.plugins) {\n        that.plugins.forEach(element => {\n          const pluginFunc = isString(element) ? _innerPlugins[element] : element;\n          pluginFunc(that.storeInstance);\n        });\n      }\n      // 绑定属性关系\n      Object.defineProperty(this, 'state', {\n        get: function() { return wrapDataInstance(this.data); }\n      });\n      this.$getters = wrapDataInstance(this.state.$getters);\n      // this.$global = wrapDataInstance({ ...this.state.$global });\n      // 获取其他 store 的只读数据\n      this.$getState = function(name) {\n        if (!name) return this.state;\n        return global.getState(name);\n      };\n      this.$getRef = function(name) {\n        return global.getComponentRef(name);\n      };\n\n      if (originOnLoad) {\n        originOnLoad.call(this, query, contextData);\n      }\n    };\n    console.log(config.data)\n    return {\n      ...config,\n      ...createHelpers.call(this, that.actions, that.mutations, that.$emitter)\n    };\n  }\n  // connect(options) {\n  //   const { mapStateToProps = [], mapGettersToProps } = options;\n  //   const that = this;\n  //   return function (config) {\n  //     const _didMount = config.didMount;\n  //     Object.assign(that.mutations, config.mutations || {});\n  //     return {\n  //       ...config,\n  //       methods: {\n  //         ...config.methods,\n  //         ...createConnectHelpers.call(this, that)\n  //       },\n  //       didMount() {\n  //         const initialData = setDataByStateProps(mapStateToProps, that.getInstance().data, config, mapGettersToProps);\n  //         this.setData(initialData);\n  //         if (mapStateToProps) {\n  //           that.$emitter.addListener('updateState', ({state = {}}) => {\n  //             const nextData = setDataByStateProps(mapStateToProps, state, config, mapGettersToProps);\n  //             this.setData(nextData);\n  //           });\n  //         }\n  //         if (typeof _didMount === 'function') {\n  //           _didMount.call(this);\n  //         }\n  //       }\n  //     };\n  //   };\n  // }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Store;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'connect', { enumerable: true, configurable: true, get: function() { return connect; } });Object.defineProperty(exports, 'GlobalStore', { enumerable: true, configurable: true, get: function() { return GlobalStore; } });\n\n\n\n","// {%TITLE=判断%}\n\n// -------------------- 常用数据类型判断 ------------------------------\n\n// 输入任意类型, 判断是否是 array 类型\nvar isArray = Array.isArray || function isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n// 判断是否为 object 对象\n/**\n * Solves equations of the form a * x = b\n * @example <caption>Example usage of method1.</caption>\n * {%isObject%}\n * @returns {Number} Returns the value of x for the equation.\n */\nfunction isObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n};\n\nfunction isString(str) {\n  return Object.prototype.toString.call(str) === '[object String]';\n};\n\nfunction isPromise(e) {\n  return !!e && typeof e.then === 'function';\n};\n\nfunction isSymbol(d) {\n  return Object.prototype.toString.call(d) === '[object Symbol]';\n}\n\nfunction isFunc(fuc) {\n  const t = Object.prototype.toString.call(fuc);\n  return t === '[object Function]' || t === '[object AsyncFunction]';\n}\n// TODO: is empty\n\nfunction isEmptyObject(obj) {\n  if (!isObject(obj)) {\n    return false;\n  }\n  return !Object.keys(obj).length;\n}\n\nfunction canParseJson(string) {\n  try {\n    return JSON.parse(string);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isTelNum(mobile) {\n  return mobile && /^1\\d{10}$/.test(mobile);\n}\n\n// ------------------- 常用设备的系统判断, android or ios ------------\n\nfunction isIOS() {\n  return /iPhone|iTouch|iPad/i.test(navigator.userAgent);\n}\n\nfunction isAndroid() {\n  return /android/i.test(navigator.userAgent);\n}\n\nmodule.exports = {\n  isArray,\n  isObject,\n  isString,\n  isEmptyObject,\n  isSymbol,\n  isFunc,\n  isPromise,\n  canParseJson,\n  // -------\n  isTelNum,\n  // ------\n  isIOS,\n  isAndroid\n};\n","function EventEmitter() {}\n\nvar proto = EventEmitter.prototype;\nvar originalGlobalValue = exports.EventEmitter;\n\nfunction indexOfListener(listeners, listener) {\n  var i = listeners.length;\n  while (i--) {\n    if (listeners[i].listener === listener) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction alias(name) {\n  return function aliasClosure() {\n    return this[name].apply(this, arguments);\n  };\n}\n\nproto.getListeners = function getListeners(evt) {\n  var events = this._getEvents();\n  var response;\n  var key;\n\n  if (evt instanceof RegExp) {\n    response = {};\n    for (key in events) {\n      if (events.hasOwnProperty(key) && evt.test(key)) {\n        response[key] = events[key];\n      }\n    }\n  } else {\n    response = events[evt] || (events[evt] = []);\n  }\n\n  return response;\n};\n\n/**\n * Takes a list of listener objects and flattens it into a list of listener functions.\n *\n * @param {Object[]} listeners Raw listener objects.\n * @return {Function[]} Just the listener functions.\n */\nproto.flattenListeners = function flattenListeners(listeners) {\n  var flatListeners = [];\n  var i;\n\n  for (i = 0; i < listeners.length; i += 1) {\n    flatListeners.push(listeners[i].listener);\n  }\n\n  return flatListeners;\n};\n\n/**\n * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n *\n * @param {String|RegExp} evt Name of the event to return the listeners from.\n * @return {Object} All listener functions for an event in an object.\n */\nproto.getListenersAsObject = function getListenersAsObject(evt) {\n  var listeners = this.getListeners(evt);\n  var response;\n\n  if (listeners instanceof Array) {\n    response = {};\n    response[evt] = listeners;\n  }\n\n  return response || listeners;\n};\n\nfunction isValidListener(listener) {\n  if (typeof listener === 'function' || listener instanceof RegExp) {\n    return true;\n  } else if (listener && typeof listener === 'object') {\n    return isValidListener(listener.listener);\n  } else {\n    return false;\n  }\n}\n\nproto.addListener = function addListener(evt, listener) {\n  if (!isValidListener(listener)) {\n    throw new TypeError('listener must be a function');\n  }\n\n  var listeners = this.getListenersAsObject(evt);\n  var listenerIsWrapped = typeof listener === 'object';\n  var key;\n  var uid;\n  for (key in listeners) {\n    if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n      uid = `lisitener_${key}_${new Date().getTime()}`;\n      listeners[key].push(listenerIsWrapped ? listener : {\n        listener: listener,\n        once: false,\n        uid\n      });\n    }\n  }\n  return function() {\n    const removeIndex = listeners[key].findIndex(o => o.uid === uid);\n    if (removeIndex !== -1) {\n      listeners[key].splice(removeIndex, 1);\n    }\n    return proto;\n  };\n};\n\nproto.on = alias('addListener');\n\nproto.addOnceListener = function addOnceListener(evt, listener) {\n  return this.addListener(evt, {\n    listener: listener,\n    once: true\n  });\n};\n\nproto.once = alias('addOnceListener');\n\nproto.defineEvent = function defineEvent(evt) {\n  this.getListeners(evt);\n  return this;\n};\n\nproto.defineEvents = function defineEvents(evts) {\n  for (var i = 0; i < evts.length; i += 1) {\n    this.defineEvent(evts[i]);\n  }\n  return this;\n};\n\nproto.removeListener = function removeListener(evt, listener) {\n  var listeners = this.getListenersAsObject(evt);\n  var index;\n  var key;\n\n  for (key in listeners) {\n    if (listeners.hasOwnProperty(key)) {\n      index = indexOfListener(listeners[key], listener);\n      if (index !== -1) {\n        listeners[key].splice(index, 1);\n      }\n    }\n  }\n\n  return this;\n};\n\nproto.off = alias('removeListener');\n\nproto.addListeners = function addListeners(evt, listeners) {\n  return this.manipulateListeners(false, evt, listeners);\n};\n\nproto.removeListeners = function removeListeners(evt, listeners) {\n  return this.manipulateListeners(true, evt, listeners);\n};\n\nproto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n  var i;\n  var value;\n  var single = remove ? this.removeListener : this.addListener;\n  var multiple = remove ? this.removeListeners : this.addListeners;\n\n    // If evt is an object then pass each of its properties to this method\n  if (typeof evt === 'object' && !(evt instanceof RegExp)) {\n    for (i in evt) {\n      if (evt.hasOwnProperty(i) && (value = evt[i])) {\n        if (typeof value === 'function') {\n          single.call(this, i, value);\n        } else {\n          multiple.call(this, i, value);\n        }\n      }\n    }\n  } else {\n    i = listeners.length;\n    while (i--) {\n      single.call(this, evt, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nproto.removeEvent = function removeEvent(evt) {\n  var type = typeof evt;\n  var events = this._getEvents();\n  var key;\n  if (type === 'string') {\n    delete events[evt];\n  } else if (evt instanceof RegExp) {\n        // Remove all events matching the regex.\n    for (key in events) {\n      if (events.hasOwnProperty(key) && evt.test(key)) {\n        delete events[key];\n      }\n    }\n  } else {\n    delete this._events;\n  }\n\n  return this;\n};\n\nproto.removeAllListeners = alias('removeEvent');\n\nproto.emitEvent = function emitEvent(evt, args) {\n  var listenersMap = this.getListenersAsObject(evt);\n  var listeners;\n  var listener;\n  var i;\n  var key;\n  var response;\n  for (key in listenersMap) {\n    if (listenersMap.hasOwnProperty(key)) {\n      listeners = listenersMap[key].slice(0);\n\n      for (i = 0; i < listeners.length; i++) {\n        listener = listeners[i];\n        if (listener.once === true) {\n          this.removeListener(evt, listener.listener);\n        }\n        response = listener.listener.call(this, args || []);\n        if (response === this._getOnceReturnValue()) {\n          this.removeListener(evt, listener.listener);\n        }\n      }\n    }\n  }\n\n  return this;\n};\n\nproto.emitEventChain = function emitEventWithNext(evt, args, cb = d => d) {\n  var listenersMap = this.getListenersAsObject(evt);\n  var listeners;\n  var key;\n  for (key in listenersMap) {\n    if (listenersMap.hasOwnProperty(key)) {\n      listeners = listenersMap[key].slice(0);\n      listeners.push({\n        listener: function(action, next, last = {}) {\n          // 最后一个回调获取最终上一次的结果\n          cb(last);\n        }\n      });\n      const that = this;\n      (function createNextFunc(i) {\n        const listener = listeners[i];\n        if (!listener) {\n          return d => d;\n        }\n        if (listener.once === true) {\n          this.removeListener(evt, listener.listener);\n        }\n        return listener.listener.bind(that, args || [], createNextFunc(i + 1));\n      })(0)();\n    }\n  }\n  return this;\n};\n\nproto.trigger = alias('emitEvent');\nproto.emit = function emit(evt) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this.emitEvent(evt, args);\n};\n\nproto.setOnceReturnValue = function setOnceReturnValue(value) {\n  this._onceReturnValue = value;\n  return this;\n};\n\nproto._getOnceReturnValue = function _getOnceReturnValue() {\n  if (this.hasOwnProperty('_onceReturnValue')) {\n    return this._onceReturnValue;\n  } else {\n    return true;\n  }\n};\n\nproto._getEvents = function _getEvents() {\n  return this._events || (this._events = {});\n};\n\nEventEmitter.noConflict = function noConflict() {\n  exports.EventEmitter = originalGlobalValue;\n  return EventEmitter;\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = EventEmitter;\n","var __TEMP__ = require('./logger');var Logger = __REQUIRE_DEFAULT__(__TEMP__);\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = {\n  logger: Logger()\n};\n","var __TEMP__ = require('./utils/is');var isString = __TEMP__['isString'];var isSymbol = __TEMP__['isSymbol'];\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function logger (option = {}) {\n  return function (store) {\n    store.subscribe((mutation, state, prevState) => {\n      const payload = isString(mutation.payload) ? mutation.payload : { ...mutation.payload };\n      console.info(`%c ${store.instanceName}Store:prev state`, 'color: #9E9E9E; font-weight: bold', prevState);\n      console.info(`%c ${store.instanceName}Store:mutation: ${mutation.type}`, 'color: #03A9F4; font-weight: bold', payload, new Date().getTime());\n      console.info(`%c ${store.instanceName}Store:next state`, 'color: #4CAF50; font-weight: bold', state);\n    }, (action = {}, next) => {\n      let type = isSymbol(action.type) ? action.type.toString() : action.type;\n      const payload = isString(action.payload) ? action.payload : { ...action.payload };\n      console.info(`%c ${store.instanceName}Store:action ${type} dispatching`, 'color: #9E9E9E; font-weight: bold', payload);\n      next();\n    });\n  };\n};exports.default = logger\n","var __TEMP__ = require('./utils/is');var isFunc = __TEMP__['isFunc'];\nvar __TEMP__ = require('./wrapDataInstance');var wrapInstance = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./global');var global = __REQUIRE_DEFAULT__(__TEMP__);\n\nfunction filterObjectByKey(array, object) {\n  return array.reduce((p, v) => {\n    if (object && object[v] !== undefined) {\n      p[v] = object[v];\n    }\n    return p;\n  }, {});\n};\n// 微信小程序不支持，需要转换成 $watch\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function mapGettersToState(state, getters = {}, store) {\n  const result = { ...state };\n  result.$getters = Object.keys(getters).reduce((p, v) => {\n    const funcExec = getters[v];\n    p[v] = {};\n    Object.defineProperty(p, v, {\n      get: function() {\n        const globalData = store.connectGlobal ? global.getGlobalState(store.mapGlobal) : {};\n        const instance = store.getInstance() ? (store.getInstance().state || {}) : (this || {});\n        if (isFunc(funcExec)) {\n          const params = filterObjectByKey(Object.keys(state), instance);\n          return funcExec.call(this, wrapInstance(params), wrapInstance(instance.$getters), wrapInstance(globalData), global.getState);\n        }\n        return funcExec;\n      }\n    });\n    return p;\n  }, {});\n  return result;\n};exports.default = mapGettersToState\n","var __TEMP__ = require('./utils/manipulate');var getIn = __TEMP__['getIn'];var setIn = __TEMP__['setIn'];var deleteIn = __TEMP__['deleteIn'];var compose = __TEMP__['compose'];var produce = __TEMP__['produce'];var update = __TEMP__['update'];\nvar __TEMP__ = require('./utils/is');var isArray = __TEMP__['isArray'];var isString = __TEMP__['isString'];\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = function(instance = {}, context) {\n  // 当实例不是引用则不做wrap\n  if (isString(instance) || typeof instance === 'number' || typeof instance === 'boolean') return instance;\n  instance.getIn = function(path, initial, ...funcs) {\n    const ctx = context ? context.data : this;\n    const pathArray = isString(path) ? [path] : path;\n    const result = getIn(ctx, pathArray, initial);\n    if (funcs.length) {\n      return compose([result].concat(funcs));\n    }\n    return result;\n  };\n  instance.setIn = function(path, initial) {\n    const ctx = context ? context.data : this;\n    const pathArray = isString(path) ? [path] : path;\n    return setIn(ctx, pathArray, initial);\n  };\n  instance.deleteIn = function(path) {\n    const ctx = context ? context.data : this;\n    const pathArray = isString(path) ? [path] : path;\n    return deleteIn(ctx, pathArray);\n  };\n  // use immutablity helper\n  instance.$update = function(manipulate) {\n    const ctx = context ? context.data : this;\n    return update(ctx, manipulate);\n  };\n  // use immer\n  instance.$produce = function(manipulate) {\n    const ctx = context ? context.data : this;\n    return produce(ctx, manipulate);\n  };\n\n  instance.compose = function(...args) {\n    const ctx = context ? context.data : this;\n    let composeArray = isArray(args[0]) ? args[0] : args;\n    composeArray.unshift(ctx);\n    return compose(composeArray);\n  };\n  return instance;\n};\n","// {%TITLE=操作%}\nvar __TEMP__ = require('./is');var isFunc = __TEMP__['isFunc'];var isArray = __TEMP__['isArray'];var isObject = __TEMP__['isObject'];\nvar __TEMP__ = require('../libs/immutability-helper-enhanced/index');var update = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../libs/immer/index');var produce = __REQUIRE_DEFAULT__(__TEMP__);\n\n/**\n * @desc 从一个对象通过操作序列来拿里面的值，做了基本防空措施\n * @param {object} state - 需要获取的数据源\n * @param {array} array - 操作路径\n * @param {any} initial - 默认值，当没有内容的时候\n * @example <caption>Example usage of getIn.</caption>\n * // testcase\n * {%common%}\n * // getIn\n * {%getIn%}\n * @returns {any} expected - 获取的值\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getIn(state, array, initial = null) {\n  let obj = Object.assign({}, state);\n\n  for (let i = 0; i < array.length; i++) {\n    // when is undefined return init immediately\n    if (typeof obj !== 'object' || obj === null) {\n      return initial;\n    }\n\n    const prop = array[i];\n\n    obj = obj[prop];\n  }\n  if (obj === undefined || obj === null) {\n    return initial;\n  }\n\n  return obj;\n};exports.getIn = getIn\n\n/**\n * @desc 一个对象通过操作序列来设置里面的值，做到自动添加值\n * @param {object} state - 需要获取的数据源\n * @param {array} array - 操作路径\n * @param {any} initial - 默认值，当没有内容的时候\n * @example <caption>Example usage of setIn.</caption>\n * // testcase\n * {%common%}\n * // setIn\n * {%setIn%}\n * @returns {any} expected - 返回操作完成后新的值\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function setIn(state, array, value) {\n  if (!array) return state;\n  const setRecursively = function(state, array, value, index) {\n    let clone = {};\n    let prop = array[index];\n    let newState;\n\n    if (array.length > index) {\n      // get cloned object\n      if (isArray(state)) {\n        clone = state.slice(0);\n      } else {\n        clone = Object.assign({}, state);\n      }\n      // not exists, make new {}\n      newState = ((isObject(state) || isArray(state)) && state[prop] !== undefined) ? state[prop] : {};\n      clone[prop] = setRecursively(newState, array, value, index + 1);\n      return clone;\n    }\n\n    return value;\n  };\n\n  return setRecursively(state, array, value, 0);\n};exports.setIn = setIn\n\n/**\n * @desc 一个对象通过操作序列来删除里面的值, 做到防空, 返回新值\n * @param {object} state - 需要获取的数据源\n * @param {array} array - 操作路径\n * @example <caption>Example usage of deleteIn.</caption>\n * // testcase\n * {%common%}\n * // deleteIn\n * {%deleteIn%}\n * @returns {any} expected - 返回删除后新的对象 or 值\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function deleteIn(state, array) {\n  const deleteRecursively = function (state, array, index) {\n    let clone = {};\n    let prop = array[index];\n\n    // not exists, just return, delete nothing\n    if (!isObject(state) || state[prop] === undefined) {\n      return state;\n    }\n\n    // not last one, just clone\n    if (array.length - 1 !== index) {\n      if (Array.isArray(state)) {\n        clone = state.slice();\n      } else {\n        clone = Object.assign({}, state);\n      }\n\n      clone[prop] = deleteRecursively(state[prop], array, index + 1);\n\n      return clone;\n    }\n\n    // delete here\n    if (Array.isArray(state)) {\n      clone = [].concat(state.slice(0, prop), state.slice(prop + 1));\n    } else {\n      clone = Object.assign({}, state);\n      delete clone[prop];\n    }\n\n    return clone;\n  };\n\n  return deleteRecursively(state, array, 0);\n};exports.deleteIn = deleteIn\n\n/**\n * @desc 将一组操作通过 array 的形式 reduce 组合\n * @param {array} array - 组合方式\n * @example <caption>Example usage of compose.</caption>\n * {%compose%}\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function compose(array) {\n  return array.reduce((p, v) => {\n    if (isFunc(v)) {\n      return v(p);\n    }\n    if (isArray(v) && isFunc(v[0])) {\n      return v[0](p, ...v.slice(1));\n    }\n    return p;\n  });\n};exports.compose = compose\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'update', { enumerable: true, configurable: true, get: function() { return update; } });Object.defineProperty(exports, 'produce', { enumerable: true, configurable: true, get: function() { return produce; } });\n","module.exports = (function() {\nvar __MODS__ = {};\nvar __DEFINE__ = function(modId, func, req) { var m = { exports: {}, _tempexports: {} }; __MODS__[modId] = { status: 0, func: func, req: req, m: m }; };\nvar __REQUIRE__ = function(modId, source) { if(!__MODS__[modId]) return require(source); if(!__MODS__[modId].status) { var m = __MODS__[modId].m; m._exports = m._tempexports; var desp = Object.getOwnPropertyDescriptor(m, \"exports\"); if (desp && desp.configurable) Object.defineProperty(m, \"exports\", { set: function (val) { if(typeof val === \"object\" && val !== m._exports) { m._exports.__proto__ = val.__proto__; Object.keys(val).forEach(function (k) { m._exports[k] = val[k]; }); } m._tempexports = val }, get: function () { return m._tempexports; } }); __MODS__[modId].status = 1; __MODS__[modId].func(__MODS__[modId].req, m, m.exports); } return __MODS__[modId].m.exports; };\nvar __REQUIRE_WILDCARD__ = function(obj) { if(obj && obj.__esModule) { return obj; } else { var newObj = {}; if(obj != null) { for(var k in obj) { if (Object.prototype.hasOwnProperty.call(obj, k)) newObj[k] = obj[k]; } } newObj.default = obj; return newObj; } };\nvar __REQUIRE_DEFAULT__ = function(obj) { return obj && obj.__esModule ? obj.default : obj; };\n__DEFINE__(1653582160815, function(require, module, exports) {\nvar invariant = require('./invariant');\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar splice = Array.prototype.splice;\n\nvar toString = Object.prototype.toString\nvar type = function(obj) {\n  return toString.call(obj).slice(8, -1);\n}\n\nvar assign = Object.assign || /* istanbul ignore next */ function assign(target, source) {\n  getAllKeys(source).forEach(function(key) {\n    if (hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n};\n\nvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function' ?\n  function(obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)) } :\n  /* istanbul ignore next */ function(obj) { return Object.keys(obj) };\n\n/* istanbul ignore next */\nfunction copy(object) {\n  if (Array.isArray(object)) {\n    return assign(object.constructor(object.length), object)\n  } else if (type(object) === 'Map') {\n    return new Map(object)\n  } else if (type(object) === 'Set') {\n    return new Set(object)\n  } else if (object && typeof object === 'object') {\n    var prototype = Object.getPrototypeOf(object);\n    return assign(Object.create(prototype), object);\n  } else {\n    return object;\n  }\n}\n\nfunction newContext() {\n  var commands = assign({}, defaultCommands);\n  update.extend = function(directive, fn) {\n    commands[directive] = fn;\n  };\n  update.isEquals = function(a, b) { return a === b; };\n\n  return update;\n\n  function update(object, spec) {\n    if (typeof spec === 'function') {\n      spec = { $apply: spec };\n    }\n\n    if (!(Array.isArray(object) && Array.isArray(spec))) {\n      invariant(\n        !Array.isArray(spec),\n        'update(): You provided an invalid spec to update(). The spec may ' +\n        'not contain an array except as the value of $set, $push, $unshift, ' +\n        '$splice or any custom command allowing an array value.'\n      );\n    }\n\n    invariant(\n      typeof spec === 'object' && spec !== null,\n      'update(): You provided an invalid spec to update(). The spec and ' +\n      'every included key path must be plain objects containing one of the ' +\n      'following commands: %s.',\n      Object.keys(commands).join(', ')\n    );\n\n    var nextObject = object;\n    var index, key;\n    getAllKeys(spec).forEach(function(key) {\n      if (hasOwnProperty.call(commands, key)) {\n        var objectWasNextObject = object === nextObject;\n        nextObject = commands[key](spec[key], nextObject, spec, object);\n        if (objectWasNextObject && update.isEquals(nextObject, object)) {\n          nextObject = object;\n        }\n      } else {\n        var nextValueForKey =\n          type(object) === 'Map'\n            ? update(object.get(key), spec[key])\n            : update(object[key], spec[key]);\n        var nextObjectValue =\n          type(nextObject) === 'Map'\n              ? nextObject.get(key)\n              : nextObject[key];\n        if (!update.isEquals(nextValueForKey, nextObjectValue) || typeof nextValueForKey === 'undefined' && !hasOwnProperty.call(object, key)) {\n          if (nextObject === object) {\n            nextObject = copy(object);\n          }\n          if (type(nextObject) === 'Map') {\n            nextObject.set(key, nextValueForKey);\n          } else {\n            nextObject[key] = nextValueForKey;\n          }\n        }\n      }\n    })\n    return nextObject;\n  }\n\n}\n\nvar defaultCommands = {\n  $push: function(value, nextObject, spec) {\n    invariantPushAndUnshift(nextObject, spec, '$push');\n    return value.length ? nextObject.concat(value) : nextObject;\n  },\n  $unshift: function(value, nextObject, spec) {\n    invariantPushAndUnshift(nextObject, spec, '$unshift');\n    return value.length ? value.concat(nextObject) : nextObject;\n  },\n  $splice: function(value, nextObject, spec, originalObject) {\n    invariantSplices(nextObject, spec);\n    value.forEach(function(args) {\n      invariantSplice(args);\n      if (nextObject === originalObject && args.length) nextObject = copy(originalObject);\n      splice.apply(nextObject, args);\n    });\n    return nextObject;\n  },\n  $set: function(value, nextObject, spec) {\n    invariantSet(spec);\n    return value;\n  },\n  $toggle: function(targets, nextObject) {\n    invariantSpecArray(targets, '$toggle');\n    var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n\n    targets.forEach(function(target) {\n      nextObjectCopy[target] = !nextObject[target];\n    });\n\n    return nextObjectCopy;\n  },\n  $unset: function(value, nextObject, spec, originalObject) {\n    invariantSpecArray(value, '$unset');\n    value.forEach(function(key) {\n      if (Object.hasOwnProperty.call(nextObject, key)) {\n        if (nextObject === originalObject) nextObject = copy(originalObject);\n        delete nextObject[key];\n      }\n    });\n    return nextObject;\n  },\n  $add: function(value, nextObject, spec, originalObject) {\n    invariantMapOrSet(nextObject, '$add');\n    invariantSpecArray(value, '$add');\n    if (type(nextObject) === 'Map') {\n      value.forEach(function(pair) {\n        var key = pair[0];\n        var value = pair[1];\n        if (nextObject === originalObject && nextObject.get(key) !== value) nextObject = copy(originalObject);\n        nextObject.set(key, value);\n      });\n    } else {\n      value.forEach(function(value) {\n        if (nextObject === originalObject && !nextObject.has(value)) nextObject = copy(originalObject);\n        nextObject.add(value);\n      });\n    }\n    return nextObject;\n  },\n  $remove: function(value, nextObject, spec, originalObject) {\n    invariantMapOrSet(nextObject, '$remove');\n    invariantSpecArray(value, '$remove');\n    value.forEach(function(key) {\n      if (nextObject === originalObject && nextObject.has(key)) nextObject = copy(originalObject);\n      nextObject.delete(key);\n    });\n    return nextObject;\n  },\n  $merge: function(value, nextObject, spec, originalObject) {\n    invariantMerge(nextObject, value);\n    getAllKeys(value).forEach(function(key) {\n      if (value[key] !== nextObject[key]) {\n        if (nextObject === originalObject) nextObject = copy(originalObject);\n        nextObject[key] = value[key];\n      }\n    });\n    return nextObject;\n  },\n  $apply: function(value, original) {\n    invariantApply(value);\n    return value(original);\n  }\n};\n\nvar contextForExport = newContext();\n\nmodule.exports = contextForExport;\nmodule.exports.default = contextForExport;\nmodule.exports.newContext = newContext;\n\n// invariants\n\nfunction invariantPushAndUnshift(value, spec, command) {\n  invariant(\n    Array.isArray(value),\n    'update(): expected target of %s to be an array; got %s.',\n    command,\n    value\n  );\n  invariantSpecArray(spec[command], command)\n}\n\nfunction invariantSpecArray(spec, command) {\n  invariant(\n    Array.isArray(spec),\n    'update(): expected spec of %s to be an array; got %s. ' +\n    'Did you forget to wrap your parameter in an array?',\n    command,\n    spec\n  );\n}\n\nfunction invariantSplices(value, spec) {\n  invariant(\n    Array.isArray(value),\n    'Expected $splice target to be an array; got %s',\n    value\n  );\n  invariantSplice(spec['$splice']);\n}\n\nfunction invariantSplice(value) {\n  invariant(\n    Array.isArray(value),\n    'update(): expected spec of $splice to be an array of arrays; got %s. ' +\n    'Did you forget to wrap your parameters in an array?',\n    value\n  );\n}\n\nfunction invariantApply(fn) {\n  invariant(\n    typeof fn === 'function',\n    'update(): expected spec of $apply to be a function; got %s.',\n    fn\n  );\n}\n\nfunction invariantSet(spec) {\n  invariant(\n    Object.keys(spec).length === 1,\n    'Cannot have more than one key in an object with $set'\n  );\n}\n\nfunction invariantMerge(target, specValue) {\n  invariant(\n    specValue && typeof specValue === 'object',\n    'update(): $merge expects a spec of type \\'object\\'; got %s',\n    specValue\n  );\n  invariant(\n    target && typeof target === 'object',\n    'update(): $merge expects a target of type \\'object\\'; got %s',\n    target\n  );\n}\n\nfunction invariantMapOrSet(target, command) {\n  var typeOfTarget = type(target);\n  invariant(\n    typeOfTarget === 'Map' || typeOfTarget === 'Set',\n    'update(): %s expects a target of type Set or Map; got %s',\n    command,\n    typeOfTarget\n  );\n}\n\n}, function(modId) {var map = {\"./invariant\":1653582160816}; return __REQUIRE__(map[modId], modId); })\n__DEFINE__(1653582160816, function(require, module, exports) {\n// https://github.com/zertosh/invariant/blob/master/browser.js\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  // if (process.env.NODE_ENV !== 'production') {\n  //   if (format === undefined) {\n  //     throw new Error('invariant requires an error message argument');\n  //   }\n  // }\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })\nreturn __REQUIRE__(1653582160815);\n})()\n//miniprogram-npm-outsideDeps=[]\n//# sourceMappingURL=index.js.map","module.exports = (function() {\nvar __MODS__ = {};\nvar __DEFINE__ = function(modId, func, req) { var m = { exports: {}, _tempexports: {} }; __MODS__[modId] = { status: 0, func: func, req: req, m: m }; };\nvar __REQUIRE__ = function(modId, source) { if(!__MODS__[modId]) return require(source); if(!__MODS__[modId].status) { var m = __MODS__[modId].m; m._exports = m._tempexports; var desp = Object.getOwnPropertyDescriptor(m, \"exports\"); if (desp && desp.configurable) Object.defineProperty(m, \"exports\", { set: function (val) { if(typeof val === \"object\" && val !== m._exports) { m._exports.__proto__ = val.__proto__; Object.keys(val).forEach(function (k) { m._exports[k] = val[k]; }); } m._tempexports = val }, get: function () { return m._tempexports; } }); __MODS__[modId].status = 1; __MODS__[modId].func(__MODS__[modId].req, m, m.exports); } return __MODS__[modId].m.exports; };\nvar __REQUIRE_WILDCARD__ = function(obj) { if(obj && obj.__esModule) { return obj; } else { var newObj = {}; if(obj != null) { for(var k in obj) { if (Object.prototype.hasOwnProperty.call(obj, k)) newObj[k] = obj[k]; } } newObj.default = obj; return newObj; } };\nvar __REQUIRE_DEFAULT__ = function(obj) { return obj && obj.__esModule ? obj.default : obj; };\n__DEFINE__(1653582160812, function(require, module, exports) {\n\n\n  module.exports = require('./immer.cjs.production.min.js')\n\n}, function(modId) {var map = {\"./immer.cjs.production.min.js\":1653582160813,\"./immer.cjs.development.js\":1653582160814}; return __REQUIRE__(map[modId], modId); })\n__DEFINE__(1653582160813, function(require, module, exports) {\nfunction n(n){for(var t=arguments.length,r=Array(t>1?t-1:0),e=1;e<t;e++)r[e-1]=arguments[e];throw Error(\"[Immer] minified error nr: \"+n+(r.length?\" \"+r.map((function(n){return\"'\"+n+\"'\"})).join(\",\"):\"\")+\". Find the full error at: https://bit.ly/3cXEKWf\")}function t(n){return!!n&&!!n[H]}function r(n){return!!n&&(function(n){if(!n||\"object\"!=typeof n)return!1;var t=Object.getPrototypeOf(n);if(null===t)return!0;var r=Object.hasOwnProperty.call(t,\"constructor\")&&t.constructor;return r===Object||\"function\"==typeof r&&Function.toString.call(r)===Q}(n)||Array.isArray(n)||!!n[G]||!!n.constructor[G]||c(n)||v(n))}function e(n,t,r){void 0===r&&(r=!1),0===i(n)?(r?Object.keys:T)(n).forEach((function(e){r&&\"symbol\"==typeof e||t(e,n[e],n)})):n.forEach((function(r,e){return t(e,r,n)}))}function i(n){var t=n[H];return t?t.t>3?t.t-4:t.t:Array.isArray(n)?1:c(n)?2:v(n)?3:0}function u(n,t){return 2===i(n)?n.has(t):Object.prototype.hasOwnProperty.call(n,t)}function o(n,t){return 2===i(n)?n.get(t):n[t]}function f(n,t,r){var e=i(n);2===e?n.set(t,r):3===e?(n.delete(t),n.add(r)):n[t]=r}function a(n,t){return n===t?0!==n||1/n==1/t:n!=n&&t!=t}function c(n){return W&&n instanceof Map}function v(n){return X&&n instanceof Set}function s(n){return n.i||n.u}function p(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var t=U(n);delete t[H];for(var r=T(t),e=0;e<r.length;e++){var i=r[e],u=t[i];!1===u.writable&&(u.writable=!0,u.configurable=!0),(u.get||u.set)&&(t[i]={configurable:!0,writable:!0,enumerable:u.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),t)}function l(n,u){return void 0===u&&(u=!1),h(n)||t(n)||!r(n)?n:(i(n)>1&&(n.set=n.add=n.clear=n.delete=d),Object.freeze(n),u&&e(n,(function(n,t){return l(t,!0)}),!0),n)}function d(){n(2)}function h(n){return null==n||\"object\"!=typeof n||Object.isFrozen(n)}function y(t){var r=V[t];return r||n(18,t),r}function _(n,t){V[n]||(V[n]=t)}function b(){return J}function m(n,t){t&&(y(\"Patches\"),n.o=[],n.v=[],n.s=t)}function j(n){O(n),n.p.forEach(w),n.p=null}function O(n){n===J&&(J=n.l)}function x(n){return J={p:[],l:J,h:n,_:!0,m:0}}function w(n){var t=n[H];0===t.t||1===t.t?t.j():t.O=!0}function S(t,e){e.m=e.p.length;var i=e.p[0],u=void 0!==t&&t!==i;return e.h.S||y(\"ES5\").P(e,t,u),u?(i[H].M&&(j(e),n(4)),r(t)&&(t=P(e,t),e.l||g(e,t)),e.o&&y(\"Patches\").g(i[H].u,t,e.o,e.v)):t=P(e,i,[]),j(e),e.o&&e.s(e.o,e.v),t!==B?t:void 0}function P(n,t,r){if(h(t))return t;var i=t[H];if(!i)return e(t,(function(e,u){return M(n,i,t,e,u,r)}),!0),t;if(i.A!==n)return t;if(!i.M)return g(n,i.u,!0),i.u;if(!i.R){i.R=!0,i.A.m--;var u=4===i.t||5===i.t?i.i=p(i.k):i.i;e(3===i.t?new Set(u):u,(function(t,e){return M(n,i,u,t,e,r)})),g(n,u,!1),r&&n.o&&y(\"Patches\").F(i,r,n.o,n.v)}return i.i}function M(n,e,i,o,a,c){if(t(a)){var v=P(n,a,c&&e&&3!==e.t&&!u(e.D,o)?c.concat(o):void 0);if(f(i,o,v),!t(v))return;n._=!1}if(r(a)&&!h(a)){if(!n.h.K&&n.m<1)return;P(n,a),e&&e.A.l||g(n,a)}}function g(n,t,r){void 0===r&&(r=!1),n.h.K&&n._&&l(t,r)}function A(n,t){var r=n[H];return(r?s(r):n)[t]}function z(n,t){if(t in n)for(var r=Object.getPrototypeOf(n);r;){var e=Object.getOwnPropertyDescriptor(r,t);if(e)return e;r=Object.getPrototypeOf(r)}}function E(n){n.M||(n.M=!0,n.l&&E(n.l))}function R(n){n.i||(n.i=p(n.u))}function k(n,t,r){var e=c(t)?y(\"MapSet\").$(t,r):v(t)?y(\"MapSet\").C(t,r):n.S?function(n,t){var r=Array.isArray(n),e={t:r?1:0,A:t?t.A:b(),M:!1,R:!1,D:{},l:t,u:n,k:null,i:null,j:null,I:!1},i=e,u=Y;r&&(i=[e],u=Z);var o=Proxy.revocable(i,u),f=o.revoke,a=o.proxy;return e.k=a,e.j=f,a}(t,r):y(\"ES5\").J(t,r);return(r?r.A:b()).p.push(e),e}function F(u){return t(u)||n(22,u),function n(t){if(!r(t))return t;var u,a=t[H],c=i(t);if(a){if(!a.M&&(a.t<4||!y(\"ES5\").N(a)))return a.u;a.R=!0,u=D(t,c),a.R=!1}else u=D(t,c);return e(u,(function(t,r){a&&o(a.u,t)===r||f(u,t,n(r))})),3===c?new Set(u):u}(u)}function D(n,t){switch(t){case 2:return new Map(n);case 3:return Array.from(n)}return p(n)}function K(){function n(n,t){var r=f[n];return r?r.enumerable=t:f[n]=r={configurable:!0,enumerable:t,get:function(){return Y.get(this[H],n)},set:function(t){Y.set(this[H],n,t)}},r}function r(n){for(var t=n.length-1;t>=0;t--){var r=n[t][H];if(!r.M)switch(r.t){case 5:o(r)&&E(r);break;case 4:i(r)&&E(r)}}}function i(n){for(var t=n.u,r=n.k,e=T(r),i=e.length-1;i>=0;i--){var o=e[i];if(o!==H){var f=t[o];if(void 0===f&&!u(t,o))return!0;var c=r[o],v=c&&c[H];if(v?v.u!==f:!a(c,f))return!0}}var s=!!t[H];return e.length!==T(t).length+(s?0:1)}function o(n){var t=n.k;if(t.length!==n.u.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);if(r&&!r.get)return!0;for(var e=0;e<t.length;e++)if(!t.hasOwnProperty(e))return!0;return!1}var f={};_(\"ES5\",{J:function(t,r){var e=Array.isArray(t),i=function(t,r){if(t){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,\"\"+i,n(i,!0));return e}var u=U(r);delete u[H];for(var o=T(u),f=0;f<o.length;f++){var a=o[f];u[a]=n(a,t||!!u[a].enumerable)}return Object.create(Object.getPrototypeOf(r),u)}(e,t),u={t:e?5:4,A:r?r.A:b(),M:!1,R:!1,D:{},l:r,u:t,k:i,i:null,O:!1,I:!1};return Object.defineProperty(i,H,{value:u,writable:!0}),i},P:function(n,i,f){f?t(i)&&i[H].A===n&&r(n.p):(n.o&&function n(t){if(t&&\"object\"==typeof t){var r=t[H];if(r){var i=r.u,f=r.k,a=r.D,c=r.t;if(4===c)e(f,(function(t){t!==H&&(void 0!==i[t]||u(i,t)?a[t]||n(f[t]):(a[t]=!0,E(r)))})),e(i,(function(n){void 0!==f[n]||u(f,n)||(a[n]=!1,E(r))}));else if(5===c){if(o(r)&&(E(r),a.length=!0),f.length<i.length)for(var v=f.length;v<i.length;v++)a[v]=!1;else for(var s=i.length;s<f.length;s++)a[s]=!0;for(var p=Math.min(f.length,i.length),l=0;l<p;l++)f.hasOwnProperty(l)||(a[l]=!0),void 0===a[l]&&n(f[l])}}}}(n.p[0]),r(n.p))},N:function(n){return 4===n.t?i(n):o(n)}})}function $(){function f(n){if(!r(n))return n;if(Array.isArray(n))return n.map(f);if(c(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],f(n[1])]})));if(v(n))return new Set(Array.from(n).map(f));var t=Object.create(Object.getPrototypeOf(n));for(var e in n)t[e]=f(n[e]);return u(n,G)&&(t[G]=n[G]),t}function a(n){return t(n)?f(n):n}var s=\"add\";_(\"Patches\",{W:function(t,r){return r.forEach((function(r){for(var e=r.path,u=r.op,a=t,c=0;c<e.length-1;c++){var v=i(a),p=\"\"+e[c];0!==v&&1!==v||\"__proto__\"!==p&&\"constructor\"!==p||n(24),\"function\"==typeof a&&\"prototype\"===p&&n(24),\"object\"!=typeof(a=o(a,p))&&n(15,e.join(\"/\"))}var l=i(a),d=f(r.value),h=e[e.length-1];switch(u){case\"replace\":switch(l){case 2:return a.set(h,d);case 3:n(16);default:return a[h]=d}case s:switch(l){case 1:return\"-\"===h?a.push(d):a.splice(h,0,d);case 2:return a.set(h,d);case 3:return a.add(d);default:return a[h]=d}case\"remove\":switch(l){case 1:return a.splice(h,1);case 2:return a.delete(h);case 3:return a.delete(r.value);default:return delete a[h]}default:n(17,u)}})),t},F:function(n,t,r,i){switch(n.t){case 0:case 4:case 2:return function(n,t,r,i){var f=n.u,c=n.i;e(n.D,(function(n,e){var v=o(f,n),p=o(c,n),l=e?u(f,n)?\"replace\":s:\"remove\";if(v!==p||\"replace\"!==l){var d=t.concat(n);r.push(\"remove\"===l?{op:l,path:d}:{op:l,path:d,value:p}),i.push(l===s?{op:\"remove\",path:d}:\"remove\"===l?{op:s,path:d,value:a(v)}:{op:\"replace\",path:d,value:a(v)})}}))}(n,t,r,i);case 5:case 1:return function(n,t,r,e){var i=n.u,u=n.D,o=n.i;if(o.length<i.length){var f=[o,i];i=f[0],o=f[1];var c=[e,r];r=c[0],e=c[1]}for(var v=0;v<i.length;v++)if(u[v]&&o[v]!==i[v]){var p=t.concat([v]);r.push({op:\"replace\",path:p,value:a(o[v])}),e.push({op:\"replace\",path:p,value:a(i[v])})}for(var l=i.length;l<o.length;l++){var d=t.concat([l]);r.push({op:s,path:d,value:a(o[l])})}i.length<o.length&&e.push({op:\"replace\",path:t.concat([\"length\"]),value:i.length})}(n,t,r,i);case 3:return function(n,t,r,e){var i=n.u,u=n.i,o=0;i.forEach((function(n){if(!u.has(n)){var i=t.concat([o]);r.push({op:\"remove\",path:i,value:n}),e.unshift({op:s,path:i,value:n})}o++})),o=0,u.forEach((function(n){if(!i.has(n)){var u=t.concat([o]);r.push({op:s,path:u,value:n}),e.unshift({op:\"remove\",path:u,value:n})}o++}))}(n,t,r,i)}},g:function(n,t,r,e){r.push({op:\"replace\",path:[],value:t===B?void 0:t}),e.push({op:\"replace\",path:[],value:n})}})}function C(){function t(n,t){function r(){this.constructor=n}f(n,t),n.prototype=(r.prototype=t.prototype,new r)}function i(n){n.i||(n.D=new Map,n.i=new Map(n.u))}function u(n){n.i||(n.i=new Set,n.u.forEach((function(t){if(r(t)){var e=k(n.A.h,t,n);n.p.set(t,e),n.i.add(e)}else n.i.add(t)})))}function o(t){t.O&&n(3,JSON.stringify(s(t)))}var f=function(n,t){return(f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,t){n.__proto__=t}||function(n,t){for(var r in t)t.hasOwnProperty(r)&&(n[r]=t[r])})(n,t)},a=function(){function n(n,t){return this[H]={t:2,l:t,A:t?t.A:b(),M:!1,R:!1,i:void 0,D:void 0,u:n,k:this,I:!1,O:!1},this}t(n,Map);var u=n.prototype;return Object.defineProperty(u,\"size\",{get:function(){return s(this[H]).size}}),u.has=function(n){return s(this[H]).has(n)},u.set=function(n,t){var r=this[H];return o(r),s(r).has(n)&&s(r).get(n)===t||(i(r),E(r),r.D.set(n,!0),r.i.set(n,t),r.D.set(n,!0)),this},u.delete=function(n){if(!this.has(n))return!1;var t=this[H];return o(t),i(t),E(t),t.u.has(n)?t.D.set(n,!1):t.D.delete(n),t.i.delete(n),!0},u.clear=function(){var n=this[H];o(n),s(n).size&&(i(n),E(n),n.D=new Map,e(n.u,(function(t){n.D.set(t,!1)})),n.i.clear())},u.forEach=function(n,t){var r=this;s(this[H]).forEach((function(e,i){n.call(t,r.get(i),i,r)}))},u.get=function(n){var t=this[H];o(t);var e=s(t).get(n);if(t.R||!r(e))return e;if(e!==t.u.get(n))return e;var u=k(t.A.h,e,t);return i(t),t.i.set(n,u),u},u.keys=function(){return s(this[H]).keys()},u.values=function(){var n,t=this,r=this.keys();return(n={})[L]=function(){return t.values()},n.next=function(){var n=r.next();return n.done?n:{done:!1,value:t.get(n.value)}},n},u.entries=function(){var n,t=this,r=this.keys();return(n={})[L]=function(){return t.entries()},n.next=function(){var n=r.next();if(n.done)return n;var e=t.get(n.value);return{done:!1,value:[n.value,e]}},n},u[L]=function(){return this.entries()},n}(),c=function(){function n(n,t){return this[H]={t:3,l:t,A:t?t.A:b(),M:!1,R:!1,i:void 0,u:n,k:this,p:new Map,O:!1,I:!1},this}t(n,Set);var r=n.prototype;return Object.defineProperty(r,\"size\",{get:function(){return s(this[H]).size}}),r.has=function(n){var t=this[H];return o(t),t.i?!!t.i.has(n)||!(!t.p.has(n)||!t.i.has(t.p.get(n))):t.u.has(n)},r.add=function(n){var t=this[H];return o(t),this.has(n)||(u(t),E(t),t.i.add(n)),this},r.delete=function(n){if(!this.has(n))return!1;var t=this[H];return o(t),u(t),E(t),t.i.delete(n)||!!t.p.has(n)&&t.i.delete(t.p.get(n))},r.clear=function(){var n=this[H];o(n),s(n).size&&(u(n),E(n),n.i.clear())},r.values=function(){var n=this[H];return o(n),u(n),n.i.values()},r.entries=function(){var n=this[H];return o(n),u(n),n.i.entries()},r.keys=function(){return this.values()},r[L]=function(){return this.values()},r.forEach=function(n,t){for(var r=this.values(),e=r.next();!e.done;)n.call(t,e.value,e.value,this),e=r.next()},n}();_(\"MapSet\",{$:function(n,t){return new a(n,t)},C:function(n,t){return new c(n,t)}})}var I;Object.defineProperty(exports,\"__esModule\",{value:!0});var J,N=\"undefined\"!=typeof Symbol&&\"symbol\"==typeof Symbol(\"x\"),W=\"undefined\"!=typeof Map,X=\"undefined\"!=typeof Set,q=\"undefined\"!=typeof Proxy&&void 0!==Proxy.revocable&&\"undefined\"!=typeof Reflect,B=N?Symbol.for(\"immer-nothing\"):((I={})[\"immer-nothing\"]=!0,I),G=N?Symbol.for(\"immer-draftable\"):\"__$immer_draftable\",H=N?Symbol.for(\"immer-state\"):\"__$immer_state\",L=\"undefined\"!=typeof Symbol&&Symbol.iterator||\"@@iterator\",Q=\"\"+Object.prototype.constructor,T=\"undefined\"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,U=Object.getOwnPropertyDescriptors||function(n){var t={};return T(n).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(n,r)})),t},V={},Y={get:function(n,t){if(t===H)return n;var e=s(n);if(!u(e,t))return function(n,t,r){var e,i=z(t,r);return i?\"value\"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,t);var i=e[t];return n.R||!r(i)?i:i===A(n.u,t)?(R(n),n.i[t]=k(n.A.h,i,n)):i},has:function(n,t){return t in s(n)},ownKeys:function(n){return Reflect.ownKeys(s(n))},set:function(n,t,r){var e=z(s(n),t);if(null==e?void 0:e.set)return e.set.call(n.k,r),!0;if(!n.M){var i=A(s(n),t),o=null==i?void 0:i[H];if(o&&o.u===r)return n.i[t]=r,n.D[t]=!1,!0;if(a(r,i)&&(void 0!==r||u(n.u,t)))return!0;R(n),E(n)}return n.i[t]===r&&\"number\"!=typeof r&&(void 0!==r||t in n.i)||(n.i[t]=r,n.D[t]=!0,!0)},deleteProperty:function(n,t){return void 0!==A(n.u,t)||t in n.u?(n.D[t]=!1,R(n),E(n)):delete n.D[t],n.i&&delete n.i[t],!0},getOwnPropertyDescriptor:function(n,t){var r=s(n),e=Reflect.getOwnPropertyDescriptor(r,t);return e?{writable:!0,configurable:1!==n.t||\"length\"!==t,enumerable:e.enumerable,value:r[t]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.u)},setPrototypeOf:function(){n(12)}},Z={};e(Y,(function(n,t){Z[n]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),Z.deleteProperty=function(n,t){return Z.set.call(this,n,t,void 0)},Z.set=function(n,t,r){return Y.set.call(this,n[0],t,r,n[0])};var nn=function(){function e(t){var e=this;this.S=q,this.K=!0,this.produce=function(t,i,u){if(\"function\"==typeof t&&\"function\"!=typeof i){var o=i;i=t;var f=e;return function(n){var t=this;void 0===n&&(n=o);for(var r=arguments.length,e=Array(r>1?r-1:0),u=1;u<r;u++)e[u-1]=arguments[u];return f.produce(n,(function(n){var r;return(r=i).call.apply(r,[t,n].concat(e))}))}}var a;if(\"function\"!=typeof i&&n(6),void 0!==u&&\"function\"!=typeof u&&n(7),r(t)){var c=x(e),v=k(e,t,void 0),s=!0;try{a=i(v),s=!1}finally{s?j(c):O(c)}return\"undefined\"!=typeof Promise&&a instanceof Promise?a.then((function(n){return m(c,u),S(n,c)}),(function(n){throw j(c),n})):(m(c,u),S(a,c))}if(!t||\"object\"!=typeof t){if(void 0===(a=i(t))&&(a=t),a===B&&(a=void 0),e.K&&l(a,!0),u){var p=[],d=[];y(\"Patches\").g(t,a,p,d),u(p,d)}return a}n(21,t)},this.produceWithPatches=function(n,t){if(\"function\"==typeof n)return function(t){for(var r=arguments.length,i=Array(r>1?r-1:0),u=1;u<r;u++)i[u-1]=arguments[u];return e.produceWithPatches(t,(function(t){return n.apply(void 0,[t].concat(i))}))};var r,i,u=e.produce(n,t,(function(n,t){r=n,i=t}));return\"undefined\"!=typeof Promise&&u instanceof Promise?u.then((function(n){return[n,r,i]})):[u,r,i]},\"boolean\"==typeof(null==t?void 0:t.useProxies)&&this.setUseProxies(t.useProxies),\"boolean\"==typeof(null==t?void 0:t.autoFreeze)&&this.setAutoFreeze(t.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){r(e)||n(8),t(e)&&(e=F(e));var i=x(this),u=k(this,e,void 0);return u[H].I=!0,O(i),u},i.finishDraft=function(n,t){var r=(n&&n[H]).A;return m(r,t),S(void 0,r)},i.setAutoFreeze=function(n){this.K=n},i.setUseProxies=function(t){t&&!q&&n(20),this.S=t},i.applyPatches=function(n,r){var e;for(e=r.length-1;e>=0;e--){var i=r[e];if(0===i.path.length&&\"replace\"===i.op){n=i.value;break}}e>-1&&(r=r.slice(e+1));var u=y(\"Patches\").W;return t(n)?u(n,r):this.produce(n,(function(n){return u(n,r)}))},e}(),tn=new nn,rn=tn.produce,en=tn.produceWithPatches.bind(tn),un=tn.setAutoFreeze.bind(tn),on=tn.setUseProxies.bind(tn),fn=tn.applyPatches.bind(tn),an=tn.createDraft.bind(tn),cn=tn.finishDraft.bind(tn);exports.Immer=nn,exports.applyPatches=fn,exports.castDraft=function(n){return n},exports.castImmutable=function(n){return n},exports.createDraft=an,exports.current=F,exports.default=rn,exports.enableAllPlugins=function(){K(),C(),$()},exports.enableES5=K,exports.enableMapSet=C,exports.enablePatches=$,exports.finishDraft=cn,exports.freeze=l,exports.immerable=G,exports.isDraft=t,exports.isDraftable=r,exports.nothing=B,exports.original=function(r){return t(r)||n(23,r),r[H].u},exports.produce=rn,exports.produceWithPatches=en,exports.setAutoFreeze=un,exports.setUseProxies=on;\n//# sourceMappingURL=immer.cjs.production.min.js.map\n\n}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })\n__DEFINE__(1653582160814, function(require, module, exports) {\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar _ref;\n\n// Should be no imports here!\n// Some things that should be evaluated before all else...\n// We only want to know if non-polyfilled symbols are available\nvar hasSymbol = typeof Symbol !== \"undefined\" && typeof\n/*#__PURE__*/\nSymbol(\"x\") === \"symbol\";\nvar hasMap = typeof Map !== \"undefined\";\nvar hasSet = typeof Set !== \"undefined\";\nvar hasProxies = typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\";\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\n\nvar NOTHING = hasSymbol ?\n/*#__PURE__*/\nSymbol.for(\"immer-nothing\") : (_ref = {}, _ref[\"immer-nothing\"] = true, _ref);\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\n\nvar DRAFTABLE = hasSymbol ?\n/*#__PURE__*/\nSymbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = hasSymbol ?\n/*#__PURE__*/\nSymbol.for(\"immer-state\") : \"__$immer_state\"; // Even a polyfilled Symbol might provide Symbol.iterator\n\nvar iteratorSymbol = typeof Symbol != \"undefined\" && Symbol.iterator || \"@@iterator\";\n\nvar errors = {\n  0: \"Illegal state\",\n  1: \"Immer drafts cannot have computed properties\",\n  2: \"This object has been frozen and should not be mutated\",\n  3: function _(data) {\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n  },\n  4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n  5: \"Immer forbids circular references\",\n  6: \"The first or second argument to `produce` must be a function\",\n  7: \"The third argument to `produce` must be a function or undefined\",\n  8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n  9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n  10: \"The given draft is already finalized\",\n  11: \"Object.defineProperty() cannot be used on an Immer draft\",\n  12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n  13: \"Immer only supports deleting array indices\",\n  14: \"Immer only supports setting array indices and the 'length' property\",\n  15: function _(path) {\n    return \"Cannot apply patch, path doesn't resolve: \" + path;\n  },\n  16: 'Sets cannot have \"replace\" patches.',\n  17: function _(op) {\n    return \"Unsupported patch operation: \" + op;\n  },\n  18: function _(plugin) {\n    return \"The plugin for '\" + plugin + \"' has not been loaded into Immer. To enable the plugin, import and call `enable\" + plugin + \"()` when initializing your application.\";\n  },\n  20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n  21: function _(thing) {\n    return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\" + thing + \"'\";\n  },\n  22: function _(thing) {\n    return \"'current' expects a draft, got: \" + thing;\n  },\n  23: function _(thing) {\n    return \"'original' expects a draft, got: \" + thing;\n  },\n  24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n};\nfunction die(error) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  {\n    var e = errors[error];\n    var msg = !e ? \"unknown error nr: \" + error : typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(\"[Immer] \" + msg);\n  }\n}\n\n/** Returns true if the given value is an Immer draft */\n\n/*#__PURE__*/\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n/** Returns true if the given value can be drafted by Immer */\n\n/*#__PURE__*/\n\nfunction isDraftable(value) {\n  if (!value) return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\nvar objectCtorString =\n/*#__PURE__*/\nObject.prototype.constructor.toString();\n/*#__PURE__*/\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") return false;\n  var proto = Object.getPrototypeOf(value);\n\n  if (proto === null) {\n    return true;\n  }\n\n  var Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object) return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n  if (!isDraft(value)) die(23, value);\n  return value[DRAFT_STATE].base_;\n}\n/*#__PURE__*/\n\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} :\n/* istanbul ignore next */\nObject.getOwnPropertyNames;\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {\n  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n  var res = {};\n  ownKeys(target).forEach(function (key) {\n    res[key] = Object.getOwnPropertyDescriptor(target, key);\n  });\n  return res;\n};\nfunction each(obj, iter, enumerableOnly) {\n  if (enumerableOnly === void 0) {\n    enumerableOnly = false;\n  }\n\n  if (getArchtype(obj) === 0\n  /* Object */\n  ) {\n      (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function (key) {\n        if (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj);\n      });\n    } else {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  }\n}\n/*#__PURE__*/\n\nfunction getArchtype(thing) {\n  /* istanbul ignore next */\n  var state = thing[DRAFT_STATE];\n  return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5\n  : state.type_ // others are the same\n  : Array.isArray(thing) ? 1\n  /* Array */\n  : isMap(thing) ? 2\n  /* Map */\n  : isSet(thing) ? 3\n  /* Set */\n  : 0\n  /* Object */\n  ;\n}\n/*#__PURE__*/\n\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2\n  /* Map */\n  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n/*#__PURE__*/\n\nfunction get(thing, prop) {\n  // @ts-ignore\n  return getArchtype(thing) === 2\n  /* Map */\n  ? thing.get(prop) : thing[prop];\n}\n/*#__PURE__*/\n\nfunction set(thing, propOrOldValue, value) {\n  var t = getArchtype(thing);\n  if (t === 2\n  /* Map */\n  ) thing.set(propOrOldValue, value);else if (t === 3\n  /* Set */\n  ) {\n      thing.delete(propOrOldValue);\n      thing.add(value);\n    } else thing[propOrOldValue] = value;\n}\n/*#__PURE__*/\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n/*#__PURE__*/\n\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\n/*#__PURE__*/\n\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\n/*#__PURE__*/\n\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\n/*#__PURE__*/\n\nfunction shallowCopy(base) {\n  if (Array.isArray(base)) return Array.prototype.slice.call(base);\n  var descriptors = getOwnPropertyDescriptors(base);\n  delete descriptors[DRAFT_STATE];\n  var keys = ownKeys(descriptors);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var desc = descriptors[key];\n\n    if (desc.writable === false) {\n      desc.writable = true;\n      desc.configurable = true;\n    } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n    // with libraries that trap values, like mobx or vue\n    // unlike object.assign, non-enumerables will be copied as well\n\n\n    if (desc.get || desc.set) descriptors[key] = {\n      configurable: true,\n      writable: true,\n      enumerable: desc.enumerable,\n      value: base[key]\n    };\n  }\n\n  return Object.create(Object.getPrototypeOf(base), descriptors);\n}\nfunction freeze(obj, deep) {\n  if (deep === void 0) {\n    deep = false;\n  }\n\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n\n  if (getArchtype(obj) > 1\n  /* Map or Set */\n  ) {\n      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n    }\n\n  Object.freeze(obj);\n  if (deep) each(obj, function (key, value) {\n    return freeze(value, true);\n  }, true);\n  return obj;\n}\n\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\n\nfunction isFrozen(obj) {\n  if (obj == null || typeof obj !== \"object\") return true; // See #600, IE dies on non-objects in Object.isFrozen\n\n  return Object.isFrozen(obj);\n}\n\n/** Plugin utilities */\n\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n  var plugin = plugins[pluginKey];\n\n  if (!plugin) {\n    die(18, pluginKey);\n  } // @ts-ignore\n\n\n  return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n}\n\nvar currentScope;\nfunction getCurrentScope() {\n  if ( !currentScope) die(0);\n  return currentScope;\n}\n\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_: parent_,\n    immer_: immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\n\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\"); // assert we have the plugin\n\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft); // @ts-ignore\n\n  scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\nfunction enterScope(immer) {\n  return currentScope = createScope(currentScope, immer);\n}\n\nfunction revokeDraft(draft) {\n  var state = draft[DRAFT_STATE];\n  if (state.type_ === 0\n  /* ProxyObject */\n  || state.type_ === 1\n  /* ProxyArray */\n  ) state.revoke_();else state.revoked_ = true;\n}\n\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  var baseDraft = scope.drafts_[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  if (!scope.immer_.useProxies_) getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = finalize(scope, result);\n      if (!scope.parent_) maybeFreeze(scope, result);\n    }\n\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\n    }\n  } else {\n    // Finalize the base draft.\n    result = finalize(scope, baseDraft, []);\n  }\n\n  revokeScope(scope);\n\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n\n  return result !== NOTHING ? result : undefined;\n}\n\nfunction finalize(rootScope, value, path) {\n  // Don't recurse in tho recursive data structures\n  if (isFrozen(value)) return value;\n  var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts\n\n  if (!state) {\n    each(value, function (key, childValue) {\n      return finalizeProperty(rootScope, state, value, key, childValue, path);\n    }, true // See #590, don't recurse into non-enumerable of non drafted objects\n    );\n    return value;\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original\n\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  } // Not finalized yet, let's do that now\n\n\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    var result = // For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n    state.type_ === 4\n    /* ES5Object */\n    || state.type_ === 5\n    /* ES5Array */\n    ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy\n    // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n    // Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n    // back to each(result, ....)\n\n    each(state.type_ === 3\n    /* Set */\n    ? new Set(result) : result, function (key, childValue) {\n      return finalizeProperty(rootScope, state, result, key, childValue, path);\n    }); // everything inside is frozen, we can freeze here\n\n    maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches\n\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\n    }\n  }\n\n  return state.copy_;\n}\n\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath) {\n  if ( childValue === targetObject) die(5);\n\n  if (isDraft(childValue)) {\n    var path = rootPath && parentState && parentState.type_ !== 3\n    /* Set */\n    && // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.\n    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.\n\n    var res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen\n    // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else return;\n  } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\n\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      // optimization: if an object is not a draft, and we don't have to\n      // deepfreeze everything, and we are sure that no drafts are left in the remaining object\n      // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n      // This benefits especially adding large data tree's without further processing.\n      // See add-data.js perf test\n      return;\n    }\n\n    finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\n    if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);\n  }\n}\n\nfunction maybeFreeze(scope, value, deep) {\n  if (deep === void 0) {\n    deep = false;\n  }\n\n  if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n}\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\n\nfunction createProxyProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var state = {\n    type_: isArray ? 1\n    /* ProxyArray */\n    : 0\n    /* ProxyObject */\n    ,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  }; // the traps must target something, a bit like the 'real' base.\n  // but also, we need to be able to determine from the target what the relevant state is\n  // (to avoid creating traps per instance to capture the state in closure,\n  // and to avoid creating weird hidden properties as well)\n  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\n  var target = state;\n  var traps = objectTraps;\n\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n\n  var _Proxy$revocable = Proxy.revocable(target, traps),\n      revoke = _Proxy$revocable.revoke,\n      proxy = _Proxy$revocable.proxy;\n\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\n/**\n * Object drafts\n */\n\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) return state;\n    var source = latest(state);\n\n    if (!has(source, prop)) {\n      // non-existing or non-own property...\n      return readPropFromProto(state, source, prop);\n    }\n\n    var value = source[prop];\n\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n    // Assigned values are never drafted. This catches any drafts we created, too.\n\n\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);\n    }\n\n    return value;\n  },\n  has: function has(state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set: function set(state, prop\n  /* strictly not, but helps TS */\n  , value) {\n    var desc = getDescriptorFromProto(latest(state), prop);\n\n    if (desc === null || desc === void 0 ? void 0 : desc.set) {\n      // special case: if this write is captured by a setter, we have\n      // to trigger it with the correct context\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n\n    if (!state.modified_) {\n      // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n      // from setting an existing property with value undefined to undefined (which is not a change)\n      var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment\n\n      var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];\n\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n\n      if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n\n    if (state.copy_[prop] === value && // special case: NaN\n    typeof value !== \"number\" && ( // special case: handle new props with value 'undefined'\n    value !== undefined || prop in state.copy_)) return true; // @ts-ignore\n\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n  deleteProperty: function deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek(state.base_, prop) !== undefined || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      // if an originally not assigned property was deleted\n      delete state.assigned_[prop];\n    } // @ts-ignore\n\n\n    if (state.copy_) delete state.copy_[prop];\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc) return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1\n      /* ProxyArray */\n      || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n  defineProperty: function defineProperty() {\n    die(11);\n  },\n  getPrototypeOf: function getPrototypeOf(state) {\n    return Object.getPrototypeOf(state.base_);\n  },\n  setPrototypeOf: function setPrototypeOf() {\n    die(12);\n  }\n};\n/**\n * Array drafts\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  // @ts-ignore\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if ( isNaN(parseInt(prop))) die(13); // @ts-ignore\n\n  return arrayTraps.set.call(this, state, prop, undefined);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if ( prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n}; // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var source = state ? latest(state) : draft;\n  return source[prop];\n}\n\nfunction readPropFromProto(state, source, prop) {\n  var _desc$get;\n\n  var desc = getDescriptorFromProto(source, prop);\n  return desc ? \"value\" in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the\n  // prototype, we should invoke it with the draft as context!\n  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;\n}\n\nfunction getDescriptorFromProto(source, prop) {\n  // 'in' checks proto!\n  if (!(prop in source)) return undefined;\n  var proto = Object.getPrototypeOf(source);\n\n  while (proto) {\n    var desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc) return desc;\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return undefined;\n}\n\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(state.base_);\n  }\n}\n\nvar Immer =\n/*#__PURE__*/\nfunction () {\n  function Immer(config) {\n    var _this = this;\n\n    this.useProxies_ = hasProxies;\n    this.autoFreeze_ = true;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n\n    this.produce = function (base, recipe, patchListener) {\n      // curried invocation\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        var defaultBase = recipe;\n        recipe = base;\n        var self = _this;\n        return function curriedProduce(base) {\n          var _this2 = this;\n\n          if (base === void 0) {\n            base = defaultBase;\n          }\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          return self.produce(base, function (draft) {\n            var _recipe;\n\n            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));\n          }); // prettier-ignore\n        };\n      }\n\n      if (typeof recipe !== \"function\") die(6);\n      if (patchListener !== undefined && typeof patchListener !== \"function\") die(7);\n      var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n      if (isDraftable(base)) {\n        var scope = enterScope(_this);\n        var proxy = createProxy(_this, base, undefined);\n        var hasError = true;\n\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          // finally instead of catch + rethrow better preserves original stack\n          if (hasError) revokeScope(scope);else leaveScope(scope);\n        }\n\n        if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n          return result.then(function (result) {\n            usePatchesInScope(scope, patchListener);\n            return processResult(result, scope);\n          }, function (error) {\n            revokeScope(scope);\n            throw error;\n          });\n        }\n\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === undefined) result = base;\n        if (result === NOTHING) result = undefined;\n        if (_this.autoFreeze_) freeze(result, true);\n\n        if (patchListener) {\n          var p = [];\n          var ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n\n        return result;\n      } else die(21, base);\n    };\n\n    this.produceWithPatches = function (arg1, arg2, arg3) {\n      if (typeof arg1 === \"function\") {\n        return function (state) {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          return _this.produceWithPatches(state, function (draft) {\n            return arg1.apply(void 0, [draft].concat(args));\n          });\n        };\n      }\n\n      var patches, inversePatches;\n\n      var result = _this.produce(arg1, arg2, function (p, ip) {\n        patches = p;\n        inversePatches = ip;\n      });\n\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then(function (nextState) {\n          return [nextState, patches, inversePatches];\n        });\n      }\n\n      return [result, patches, inversePatches];\n    };\n\n    if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === \"boolean\") this.setUseProxies(config.useProxies);\n    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === \"boolean\") this.setAutoFreeze(config.autoFreeze);\n  }\n\n  var _proto = Immer.prototype;\n\n  _proto.createDraft = function createDraft(base) {\n    if (!isDraftable(base)) die(8);\n    if (isDraft(base)) base = current(base);\n    var scope = enterScope(this);\n    var proxy = createProxy(this, base, undefined);\n    proxy[DRAFT_STATE].isManual_ = true;\n    leaveScope(scope);\n    return proxy;\n  };\n\n  _proto.finishDraft = function finishDraft(draft, patchListener) {\n    var state = draft && draft[DRAFT_STATE];\n\n    {\n      if (!state || !state.isManual_) die(9);\n      if (state.finalized_) die(10);\n    }\n\n    var scope = state.scope_;\n    usePatchesInScope(scope, patchListener);\n    return processResult(undefined, scope);\n  }\n  /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */\n  ;\n\n  _proto.setAutoFreeze = function setAutoFreeze(value) {\n    this.autoFreeze_ = value;\n  }\n  /**\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n   * always faster than using ES5 proxies.\n   *\n   * By default, feature detection is used, so calling this is rarely necessary.\n   */\n  ;\n\n  _proto.setUseProxies = function setUseProxies(value) {\n    if (value && !hasProxies) {\n      die(20);\n    }\n\n    this.useProxies_ = value;\n  };\n\n  _proto.applyPatches = function applyPatches(base, patches) {\n    // If a patch replaces the entire state, take that replacement as base\n    // before applying patches\n    var i;\n\n    for (i = patches.length - 1; i >= 0; i--) {\n      var patch = patches[i];\n\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    } // If there was a patch that replaced the entire state, start from the\n    // patch after that.\n\n\n    if (i > -1) {\n      patches = patches.slice(i + 1);\n    }\n\n    var applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n\n    if (isDraft(base)) {\n      // N.B: never hits if some patch a replacement, patches are never drafts\n      return applyPatchesImpl(base, patches);\n    } // Otherwise, produce a copy of the base state.\n\n\n    return this.produce(base, function (draft) {\n      return applyPatchesImpl(draft, patches);\n    });\n  };\n\n  return Immer;\n}();\nfunction createProxy(immer, value, parent) {\n  // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n  var draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin(\"ES5\").createES5Proxy_(value, parent);\n  var scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n}\n\nfunction current(value) {\n  if (!isDraft(value)) die(22, value);\n  return currentImpl(value);\n}\n\nfunction currentImpl(value) {\n  if (!isDraftable(value)) return value;\n  var state = value[DRAFT_STATE];\n  var copy;\n  var archType = getArchtype(value);\n\n  if (state) {\n    if (!state.modified_ && (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying\n\n    state.finalized_ = true;\n    copy = copyHelper(value, archType);\n    state.finalized_ = false;\n  } else {\n    copy = copyHelper(value, archType);\n  }\n\n  each(copy, function (key, childValue) {\n    if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change\n\n    set(copy, key, currentImpl(childValue));\n  }); // In the future, we might consider freezing here, based on the current settings\n\n  return archType === 3\n  /* Set */\n  ? new Set(copy) : copy;\n}\n\nfunction copyHelper(value, archType) {\n  // creates a shallow copy, even if it is a map or set\n  switch (archType) {\n    case 2\n    /* Map */\n    :\n      return new Map(value);\n\n    case 3\n    /* Set */\n    :\n      // Set will be cloned as array temporarily, so that we can replace individual items\n      return Array.from(value);\n  }\n\n  return shallowCopy(value);\n}\n\nfunction enableES5() {\n  function willFinalizeES5_(scope, result, isReplaced) {\n    if (!isReplaced) {\n      if (scope.patches_) {\n        markChangesRecursively(scope.drafts_[0]);\n      } // This is faster when we don't care about which attributes changed.\n\n\n      markChangesSweep(scope.drafts_);\n    } // When a child draft is returned, look for changes.\n    else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {\n        markChangesSweep(scope.drafts_);\n      }\n  }\n\n  function createES5Draft(isArray, base) {\n    if (isArray) {\n      var draft = new Array(base.length);\n\n      for (var i = 0; i < base.length; i++) {\n        Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\n      }\n\n      return draft;\n    } else {\n      var _descriptors = getOwnPropertyDescriptors(base);\n\n      delete _descriptors[DRAFT_STATE];\n      var keys = ownKeys(_descriptors);\n\n      for (var _i = 0; _i < keys.length; _i++) {\n        var key = keys[_i];\n        _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);\n      }\n\n      return Object.create(Object.getPrototypeOf(base), _descriptors);\n    }\n  }\n\n  function createES5Proxy_(base, parent) {\n    var isArray = Array.isArray(base);\n    var draft = createES5Draft(isArray, base);\n    var state = {\n      type_: isArray ? 5\n      /* ES5Array */\n      : 4\n      /* ES5Object */\n      ,\n      scope_: parent ? parent.scope_ : getCurrentScope(),\n      modified_: false,\n      finalized_: false,\n      assigned_: {},\n      parent_: parent,\n      // base is the object we are drafting\n      base_: base,\n      // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n      draft_: draft,\n      copy_: null,\n      revoked_: false,\n      isManual_: false\n    };\n    Object.defineProperty(draft, DRAFT_STATE, {\n      value: state,\n      // enumerable: false <- the default\n      writable: true\n    });\n    return draft;\n  } // property descriptors are recycled to make sure we don't create a get and set closure per property,\n  // but share them all instead\n\n\n  var descriptors = {};\n\n  function proxyProperty(prop, enumerable) {\n    var desc = descriptors[prop];\n\n    if (desc) {\n      desc.enumerable = enumerable;\n    } else {\n      descriptors[prop] = desc = {\n        configurable: true,\n        enumerable: enumerable,\n        get: function get() {\n          var state = this[DRAFT_STATE];\n          assertUnrevoked(state); // @ts-ignore\n\n          return objectTraps.get(state, prop);\n        },\n        set: function set(value) {\n          var state = this[DRAFT_STATE];\n          assertUnrevoked(state); // @ts-ignore\n\n          objectTraps.set(state, prop, value);\n        }\n      };\n    }\n\n    return desc;\n  } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\n  function markChangesSweep(drafts) {\n    // The natural order of drafts in the `scope` array is based on when they\n    // were accessed. By processing drafts in reverse natural order, we have a\n    // better chance of processing leaf nodes first. When a leaf node is known to\n    // have changed, we can avoid any traversal of its ancestor nodes.\n    for (var i = drafts.length - 1; i >= 0; i--) {\n      var state = drafts[i][DRAFT_STATE];\n\n      if (!state.modified_) {\n        switch (state.type_) {\n          case 5\n          /* ES5Array */\n          :\n            if (hasArrayChanges(state)) markChanged(state);\n            break;\n\n          case 4\n          /* ES5Object */\n          :\n            if (hasObjectChanges(state)) markChanged(state);\n            break;\n        }\n      }\n    }\n  }\n\n  function markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return;\n    var state = object[DRAFT_STATE];\n    if (!state) return;\n    var base_ = state.base_,\n        draft_ = state.draft_,\n        assigned_ = state.assigned_,\n        type_ = state.type_;\n\n    if (type_ === 4\n    /* ES5Object */\n    ) {\n        // Look for added keys.\n        // probably there is a faster way to detect changes, as sweep + recurse seems to do some\n        // unnecessary work.\n        // also: probably we can store the information we detect here, to speed up tree finalization!\n        each(draft_, function (key) {\n          if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.\n\n          if (base_[key] === undefined && !has(base_, key)) {\n            assigned_[key] = true;\n            markChanged(state);\n          } else if (!assigned_[key]) {\n            // Only untouched properties trigger recursion.\n            markChangesRecursively(draft_[key]);\n          }\n        }); // Look for removed keys.\n\n        each(base_, function (key) {\n          // The `undefined` check is a fast path for pre-existing keys.\n          if (draft_[key] === undefined && !has(draft_, key)) {\n            assigned_[key] = false;\n            markChanged(state);\n          }\n        });\n      } else if (type_ === 5\n    /* ES5Array */\n    ) {\n        if (hasArrayChanges(state)) {\n          markChanged(state);\n          assigned_.length = true;\n        }\n\n        if (draft_.length < base_.length) {\n          for (var i = draft_.length; i < base_.length; i++) {\n            assigned_[i] = false;\n          }\n        } else {\n          for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {\n            assigned_[_i2] = true;\n          }\n        } // Minimum count is enough, the other parts has been processed.\n\n\n        var min = Math.min(draft_.length, base_.length);\n\n        for (var _i3 = 0; _i3 < min; _i3++) {\n          // Only untouched indices trigger recursion.\n          if (!draft_.hasOwnProperty(_i3)) {\n            assigned_[_i3] = true;\n          }\n\n          if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);\n        }\n      }\n  }\n\n  function hasObjectChanges(state) {\n    var base_ = state.base_,\n        draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because\n    // non-numeric keys are ordered by time of definition on the object.\n\n    var keys = ownKeys(draft_);\n\n    for (var i = keys.length - 1; i >= 0; i--) {\n      var key = keys[i];\n      if (key === DRAFT_STATE) continue;\n      var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n      if (baseValue === undefined && !has(base_, key)) {\n        return true;\n      } // Once a base key is deleted, future changes go undetected, because its\n      // descriptor is erased. This branch detects any missed changes.\n      else {\n          var value = draft_[key];\n\n          var _state = value && value[DRAFT_STATE];\n\n          if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {\n            return true;\n          }\n        }\n    } // At this point, no keys were added or changed.\n    // Compare key count to determine if keys were deleted.\n\n\n    var baseIsDraft = !!base_[DRAFT_STATE];\n    return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\n  }\n\n  function hasArrayChanges(state) {\n    var draft_ = state.draft_;\n    if (draft_.length !== state.base_.length) return true; // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    // last descriptor can be not a trap, if the array was extended\n\n    var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n    if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed\n\n    for (var i = 0; i < draft_.length; i++) {\n      if (!draft_.hasOwnProperty(i)) return true;\n    } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n\n    return false;\n  }\n\n  function hasChanges_(state) {\n    return state.type_ === 4\n    /* ES5Object */\n    ? hasObjectChanges(state) : hasArrayChanges(state);\n  }\n\n  function assertUnrevoked(state\n  /*ES5State | MapState | SetState*/\n  ) {\n    if (state.revoked_) die(3, JSON.stringify(latest(state)));\n  }\n\n  loadPlugin(\"ES5\", {\n    createES5Proxy_: createES5Proxy_,\n    willFinalizeES5_: willFinalizeES5_,\n    hasChanges_: hasChanges_\n  });\n}\n\nfunction enablePatches() {\n  var REPLACE = \"replace\";\n  var ADD = \"add\";\n  var REMOVE = \"remove\";\n\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0\n      /* ProxyObject */\n      :\n      case 4\n      /* ES5Object */\n      :\n      case 2\n      /* Map */\n      :\n        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n\n      case 5\n      /* ES5Array */\n      :\n      case 1\n      /* ProxyArray */\n      :\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n\n      case 3\n      /* Set */\n      :\n        return generateSetPatches(state, basePath, patches, inversePatches);\n    }\n  }\n\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n        assigned_ = state.assigned_;\n    var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.\n\n    if (copy_.length < base_.length) {\n      var _ref = [copy_, base_];\n      base_ = _ref[0];\n      copy_ = _ref[1];\n      var _ref2 = [inversePatches, patches];\n      patches = _ref2[0];\n      inversePatches = _ref2[1];\n    } // Process replaced indices.\n\n\n    for (var i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path: path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path: path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    } // Process added indices.\n\n\n    for (var _i = base_.length; _i < copy_.length; _i++) {\n      var _path = basePath.concat([_i]);\n\n      patches.push({\n        op: ADD,\n        path: _path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[_i])\n      });\n    }\n\n    if (base_.length < copy_.length) {\n      inversePatches.push({\n        op: REPLACE,\n        path: basePath.concat([\"length\"]),\n        value: base_.length\n      });\n    }\n  } // This is used for both Map objects and normal objects.\n\n\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n        copy_ = state.copy_;\n    each(state.assigned_, function (key, assignedValue) {\n      var origValue = get(base_, key);\n      var value = get(copy_, key);\n      var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE) return;\n      var path = basePath.concat(key);\n      patches.push(op === REMOVE ? {\n        op: op,\n        path: path\n      } : {\n        op: op,\n        path: path,\n        value: value\n      });\n      inversePatches.push(op === ADD ? {\n        op: REMOVE,\n        path: path\n      } : op === REMOVE ? {\n        op: ADD,\n        path: path,\n        value: clonePatchValueIfNeeded(origValue)\n      } : {\n        op: REPLACE,\n        path: path,\n        value: clonePatchValueIfNeeded(origValue)\n      });\n    });\n  }\n\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n        copy_ = state.copy_;\n    var i = 0;\n    base_.forEach(function (value) {\n      if (!copy_.has(value)) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path: path,\n          value: value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path: path,\n          value: value\n        });\n      }\n\n      i++;\n    });\n    i = 0;\n    copy_.forEach(function (value) {\n      if (!base_.has(value)) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path: path,\n          value: value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path: path,\n          value: value\n        });\n      }\n\n      i++;\n    });\n  }\n\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? undefined : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n\n  function applyPatches_(draft, patches) {\n    patches.forEach(function (patch) {\n      var path = patch.path,\n          op = patch.op;\n      var base = draft;\n\n      for (var i = 0; i < path.length - 1; i++) {\n        var parentType = getArchtype(base);\n        var p = \"\" + path[i]; // See #738, avoid prototype pollution\n\n        if ((parentType === 0\n        /* Object */\n        || parentType === 1\n        /* Array */\n        ) && (p === \"__proto__\" || p === \"constructor\")) die(24);\n        if (typeof base === \"function\" && p === \"prototype\") die(24);\n        base = get(base, p);\n        if (typeof base !== \"object\") die(15, path.join(\"/\"));\n      }\n\n      var type = getArchtype(base);\n      var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n      var key = path[path.length - 1];\n\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2\n            /* Map */\n            :\n              return base.set(key, value);\n\n            /* istanbul ignore next */\n\n            case 3\n            /* Set */\n            :\n              die(16);\n\n            default:\n              // if value is an object, then it's assigned by reference\n              // in the following add or remove ops, the value field inside the patch will also be modifyed\n              // so we use value from the cloned patch\n              // @ts-ignore\n              return base[key] = value;\n          }\n\n        case ADD:\n          switch (type) {\n            case 1\n            /* Array */\n            :\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n\n            case 2\n            /* Map */\n            :\n              return base.set(key, value);\n\n            case 3\n            /* Set */\n            :\n              return base.add(value);\n\n            default:\n              return base[key] = value;\n          }\n\n        case REMOVE:\n          switch (type) {\n            case 1\n            /* Array */\n            :\n              return base.splice(key, 1);\n\n            case 2\n            /* Map */\n            :\n              return base.delete(key);\n\n            case 3\n            /* Set */\n            :\n              return base.delete(patch.value);\n\n            default:\n              return delete base[key];\n          }\n\n        default:\n          die(17, op);\n      }\n    });\n    return draft;\n  }\n\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj)) return obj;\n    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\n    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function (_ref3) {\n      var k = _ref3[0],\n          v = _ref3[1];\n      return [k, deepClonePatchValue(v)];\n    }));\n    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n    var cloned = Object.create(Object.getPrototypeOf(obj));\n\n    for (var key in obj) {\n      cloned[key] = deepClonePatchValue(obj[key]);\n    }\n\n    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else return obj;\n  }\n\n  loadPlugin(\"Patches\", {\n    applyPatches_: applyPatches_,\n    generatePatches_: generatePatches_,\n    generateReplacementPatches_: generateReplacementPatches_\n  });\n}\n\n// types only!\nfunction enableMapSet() {\n  /* istanbul ignore next */\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  }; // Ugly hack to resolve #502 and inherit built in Map / Set\n\n\n  function __extends(d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = ( // @ts-ignore\n    __.prototype = b.prototype, new __());\n  }\n\n  var DraftMap = function (_super) {\n    __extends(DraftMap, _super); // Create class manually, cause #502\n\n\n    function DraftMap(target, parent) {\n      this[DRAFT_STATE] = {\n        type_: 2\n        /* Map */\n        ,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: undefined,\n        assigned_: undefined,\n        base_: target,\n        draft_: this,\n        isManual_: false,\n        revoked_: false\n      };\n      return this;\n    }\n\n    var p = DraftMap.prototype;\n    Object.defineProperty(p, \"size\", {\n      get: function get() {\n        return latest(this[DRAFT_STATE]).size;\n      } // enumerable: false,\n      // configurable: true\n\n    });\n\n    p.has = function (key) {\n      return latest(this[DRAFT_STATE]).has(key);\n    };\n\n    p.set = function (key, value) {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_.set(key, true);\n        state.copy_.set(key, value);\n        state.assigned_.set(key, true);\n      }\n\n      return this;\n    };\n\n    p.delete = function (key) {\n      if (!this.has(key)) {\n        return false;\n      }\n\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareMapCopy(state);\n      markChanged(state);\n\n      if (state.base_.has(key)) {\n        state.assigned_.set(key, false);\n      } else {\n        state.assigned_.delete(key);\n      }\n\n      state.copy_.delete(key);\n      return true;\n    };\n\n    p.clear = function () {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (latest(state).size) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_ = new Map();\n        each(state.base_, function (key) {\n          state.assigned_.set(key, false);\n        });\n        state.copy_.clear();\n      }\n    };\n\n    p.forEach = function (cb, thisArg) {\n      var _this = this;\n\n      var state = this[DRAFT_STATE];\n      latest(state).forEach(function (_value, key, _map) {\n        cb.call(thisArg, _this.get(key), key, _this);\n      });\n    };\n\n    p.get = function (key) {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      var value = latest(state).get(key);\n\n      if (state.finalized_ || !isDraftable(value)) {\n        return value;\n      }\n\n      if (value !== state.base_.get(key)) {\n        return value; // either already drafted or reassigned\n      } // despite what it looks, this creates a draft only once, see above condition\n\n\n      var draft = createProxy(state.scope_.immer_, value, state);\n      prepareMapCopy(state);\n      state.copy_.set(key, draft);\n      return draft;\n    };\n\n    p.keys = function () {\n      return latest(this[DRAFT_STATE]).keys();\n    };\n\n    p.values = function () {\n      var _this2 = this,\n          _ref;\n\n      var iterator = this.keys();\n      return _ref = {}, _ref[iteratorSymbol] = function () {\n        return _this2.values();\n      }, _ref.next = function next() {\n        var r = iterator.next();\n        /* istanbul ignore next */\n\n        if (r.done) return r;\n\n        var value = _this2.get(r.value);\n\n        return {\n          done: false,\n          value: value\n        };\n      }, _ref;\n    };\n\n    p.entries = function () {\n      var _this3 = this,\n          _ref2;\n\n      var iterator = this.keys();\n      return _ref2 = {}, _ref2[iteratorSymbol] = function () {\n        return _this3.entries();\n      }, _ref2.next = function next() {\n        var r = iterator.next();\n        /* istanbul ignore next */\n\n        if (r.done) return r;\n\n        var value = _this3.get(r.value);\n\n        return {\n          done: false,\n          value: [r.value, value]\n        };\n      }, _ref2;\n    };\n\n    p[iteratorSymbol] = function () {\n      return this.entries();\n    };\n\n    return DraftMap;\n  }(Map);\n\n  function proxyMap_(target, parent) {\n    // @ts-ignore\n    return new DraftMap(target, parent);\n  }\n\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n\n  var DraftSet = function (_super) {\n    __extends(DraftSet, _super); // Create class manually, cause #502\n\n\n    function DraftSet(target, parent) {\n      this[DRAFT_STATE] = {\n        type_: 3\n        /* Set */\n        ,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: undefined,\n        base_: target,\n        draft_: this,\n        drafts_: new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n      return this;\n    }\n\n    var p = DraftSet.prototype;\n    Object.defineProperty(p, \"size\", {\n      get: function get() {\n        return latest(this[DRAFT_STATE]).size;\n      } // enumerable: true,\n\n    });\n\n    p.has = function (value) {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value\n\n      if (!state.copy_) {\n        return state.base_.has(value);\n      }\n\n      if (state.copy_.has(value)) return true;\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n      return false;\n    };\n\n    p.add = function (value) {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (!this.has(value)) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.add(value);\n      }\n\n      return this;\n    };\n\n    p.delete = function (value) {\n      if (!this.has(value)) {\n        return false;\n      }\n\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      markChanged(state);\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :\n      /* istanbul ignore next */\n      false);\n    };\n\n    p.clear = function () {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (latest(state).size) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.clear();\n      }\n    };\n\n    p.values = function () {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.values();\n    };\n\n    p.entries = function entries() {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.entries();\n    };\n\n    p.keys = function () {\n      return this.values();\n    };\n\n    p[iteratorSymbol] = function () {\n      return this.values();\n    };\n\n    p.forEach = function forEach(cb, thisArg) {\n      var iterator = this.values();\n      var result = iterator.next();\n\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, this);\n        result = iterator.next();\n      }\n    };\n\n    return DraftSet;\n  }(Set);\n\n  function proxySet_(target, parent) {\n    // @ts-ignore\n    return new DraftSet(target, parent);\n  }\n\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      // create drafts for all entries to preserve insertion order\n      state.copy_ = new Set();\n      state.base_.forEach(function (value) {\n        if (isDraftable(value)) {\n          var draft = createProxy(state.scope_.immer_, value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n\n  function assertUnrevoked(state\n  /*ES5State | MapState | SetState*/\n  ) {\n    if (state.revoked_) die(3, JSON.stringify(latest(state)));\n  }\n\n  loadPlugin(\"MapSet\", {\n    proxyMap_: proxyMap_,\n    proxySet_: proxySet_\n  });\n}\n\nfunction enableAllPlugins() {\n  enableES5();\n  enableMapSet();\n  enablePatches();\n}\n\nvar immer =\n/*#__PURE__*/\nnew Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches =\n/*#__PURE__*/\nimmer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\n\nvar setAutoFreeze =\n/*#__PURE__*/\nimmer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies =\n/*#__PURE__*/\nimmer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches =\n/*#__PURE__*/\nimmer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft =\n/*#__PURE__*/\nimmer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft =\n/*#__PURE__*/\nimmer.finishDraft.bind(immer);\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\n\nfunction castDraft(value) {\n  return value;\n}\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\n\nfunction castImmutable(value) {\n  return value;\n}\n\nexports.Immer = Immer;\nexports.applyPatches = applyPatches;\nexports.castDraft = castDraft;\nexports.castImmutable = castImmutable;\nexports.createDraft = createDraft;\nexports.current = current;\nexports.default = produce;\nexports.enableAllPlugins = enableAllPlugins;\nexports.enableES5 = enableES5;\nexports.enableMapSet = enableMapSet;\nexports.enablePatches = enablePatches;\nexports.finishDraft = finishDraft;\nexports.freeze = freeze;\nexports.immerable = DRAFTABLE;\nexports.isDraft = isDraft;\nexports.isDraftable = isDraftable;\nexports.nothing = NOTHING;\nexports.original = original;\nexports.produce = produce;\nexports.produceWithPatches = produceWithPatches;\nexports.setAutoFreeze = setAutoFreeze;\nexports.setUseProxies = setUseProxies;\n//# sourceMappingURL=immer.cjs.development.js.map\n\n}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })\nreturn __REQUIRE__(1653582160812);\n})()\n//miniprogram-npm-outsideDeps=[]\n//# sourceMappingURL=index.js.map","var __TEMP__ = require('./emitter');var EventEmitter = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./wrapDataInstance');var wrapDataInstance = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./innerPlugins');var _innerPlugins = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./utils/is');var isString = __TEMP__['isString'];\nvar __TEMP__ = require('./utils/wrapState');var wrapState = __REQUIRE_DEFAULT__(__TEMP__);\n\nclass Global {\n  constructor() {\n    this.emitter = new EventEmitter();\n    this.storeInstances = {};\n    this.components = {};\n    this.globalStoreConfig = {\n      state: {}\n    };\n    this.messageChannel = {};\n    this.router = {\n      currentPath: '',\n      query: null,\n      context: {},\n      from: '',\n      viewId: '',\n      fromViewId: ''\n    };\n    const that = this;\n    this.emitter.addListener('updateCurrentPath', path => {\n      Object.assign(that.router, path);\n      const prevState = { ...that.globalStoreConfig.state };\n      // console.info(`%c mutation: ROUTER`, 'color: #03A9F4; font-weight: bold', { ...that.router }, new Date().getTime());\n      Object.assign(that.globalStoreConfig.state, {\n        $router: that.router\n      });\n      const nextState = { ...that.globalStoreConfig.state };\n      that.emitter.emitEvent('updateGlobalStore', { nextState, prevState, type: '$global:handleRouterChanged', payload: { ...path } });\n    });\n    this.emitter.addListener('updateState', data => {\n      const { state, mutation } = data;\n      const prevState = { ...that.globalStoreConfig.state };\n      Object.assign(that.globalStoreConfig.state, state);\n      const nextState = { ...that.globalStoreConfig.state };\n      that.emitter.emitEvent('updateGlobalStore', { nextState, prevState, mutation });\n    });\n    this.messageManager = {\n      clear: this.clearMessage.bind(this),\n      push: this.pushMessage.bind(this),\n      pop: this.popMessage.bind(this)\n    };\n  }\n  subscribe(subscriber, actionSubscriber) {\n    const that = this;\n    this.emitter.addListener('updateGlobalStore', ({ nextState, prevState, mutation = {} }) => {\n      subscriber && subscriber(mutation, wrapState(nextState), wrapState(prevState));\n    });\n    // if (actionSubscriber) {\n    //   emitter.addListener('dispatchAction', (action) => {\n    //     actionSubscriber(action);\n    //   });\n    // }\n  }\n  getGlobalState(mapGlobalToState) {\n    const state = wrapDataInstance(this.globalStoreConfig.state);\n    if (mapGlobalToState) {\n      return mapGlobalToState(state);\n    }\n    return state;\n  }\n  clearMessage(channel) {\n    if (this.messageChannel[channel]) {\n      this.messageChannel[channel] = [];\n    }\n  }\n  pushMessage(channel, payload) {\n    if (this.messageChannel[channel]) {\n      this.messageChannel[channel].push(payload);\n    } else {\n      this.messageChannel[channel] = [payload];\n    }\n  }\n  popMessage(channel) {\n    if (this.messageChannel[channel]) {\n      return this.messageChannel[channel].pop();\n    } else {\n      return null;\n    }\n  }\n  getCurrentPath() {\n    return this.router.currentPath;\n  }\n  getCurrentViewId() {\n    return this.router.viewId;\n  }\n  setGlobalStoreConfig(data) {\n    this.globalStoreConfig = data;\n    this.instanceName = 'global';\n    if (this.globalStoreConfig.plugins) {\n      this.globalStoreConfig.plugins.forEach(plugin => {\n        const pluginFunc = isString(plugin) ? _innerPlugins[plugin] : plugin;\n        pluginFunc(this);\n      });\n    }\n  }\n  registerComponents(name, instance) {\n    this.components[name] = instance;\n  }\n  getComponentRef(name) {\n    if (!this.components[name]) {\n      console.warn(`未找到${name}组件，请检查组件名是否正确，是否在onReady后使用`);\n      return null;\n    }\n    return this.components[name];\n  }\n  registerInstance(name, instance) {\n    this.storeInstances[name] = instance;\n  }\n  getInstance(name) {\n    return this.storeInstances[name];\n  }\n  getInstanceByViewId(id) {\n    // 通过 viewid 找\n    const target = Object.values(this.storeInstances).find(i => i.viewId === id);\n    return target;\n  }\n  getState(name) {\n    const target = this.storeInstances[name];\n    if (target) {\n      const { store } = target;\n      const instance = store.getInstance();\n      return instance.data;\n    }\n    return null;\n  }\n}\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = new Global();\n","const reserveWord = ['getIn', 'setIn', 'deleteIn', '$update', '$produce', 'compose'];\n\nfunction omit(data) {\n  return Object.keys(data).filter(d => reserveWord.indexOf(d) < 0).reduce((p, v) => {\n    p[v] = data[v];\n    return p;\n  }, {});\n}\n// 打印时去除这类无聊信息\nfunction wrapState(state) {\n  const filteredNewState = omit(state);\n  if (filteredNewState.$getters) {\n    filteredNewState.$getters = omit(filteredNewState.$getters);\n  }\n  if (filteredNewState.$global) {\n    filteredNewState.$global = omit(filteredNewState.$global);\n  }\n  return filteredNewState;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = wrapState;\n","var __TEMP__ = require('./utils/manipulate');var setIn = __TEMP__['setIn'];var update = __TEMP__['update'];var produce = __TEMP__['produce'];var deleteIn = __TEMP__['deleteIn'];\nvar __TEMP__ = require('./utils/is');var isObject = __TEMP__['isObject'];var isFunc = __TEMP__['isFunc'];var isString = __TEMP__['isString'];\nvar __TEMP__ = require('./global');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./wrapDataInstance');var wrapDataInstance = __REQUIRE_DEFAULT__(__TEMP__);\n\n// TODO: 这个页面需要重构！\nfunction startsWith(data, search, pos) {\n  return data.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n};\n\nfunction dispatchActionPromise(instance, args) {\n  return new Promise((resolve, reject) => {\n    try {\n      instance.emitEventChain('dispatchAction', args, d => {\n        resolve(d);\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n// 保证每次更改 store 是 immutable 的\nconst innerMutation = {\n  $setIn: (s, d) => setIn(s, d.path, d.value),\n  $update: (s, o) => update(s, o),\n  $deleteIn: (s, d) => deleteIn(s, d),\n  $resetStore: function() {\n    const { config } = global.getInstanceByViewId(global.getCurrentViewId());\n    let next = { ...config.state };\n    return next;\n  }\n};\nfunction mutationHandler (func, state, payload, innerHelper) {\n  if (innerHelper) {\n    func = isFunc(innerHelper) ? func || innerHelper : func || innerMutation[innerHelper];\n  }\n  if (!func) {\n    return payload;\n  }\n  const payloadWithHelper = wrapDataInstance(payload);\n  if (func._shouldImmutable) {\n    return produce(state, draftState => {\n      func(draftState, payloadWithHelper);\n    });\n  }\n  const result = func(state, payloadWithHelper);\n  // 确保return的值是一个新对象\n  return result === state ? { ...result } : result;\n}\n\nfunction commitGlobal(type, payload, innerHelper) {\n  const {\n    mutations = {}\n  } = global.globalStoreConfig;\n  if (!type) {\n    throw new Error(`not found ${type} action`);\n  }\n  if (isObject(type)) {\n    payload = type;\n    type = 'update';\n  }\n  const finalMutation = mutationHandler(mutations[type], global.getGlobalState(), payload, innerHelper);\n  const tmp = { state: finalMutation, mutation: { type: `$global:${type}`, payload } };\n  global.emitter.emitEvent('updateState', tmp);\n  // commit 的结果是一个同步行为\n  return global.getGlobalState();\n}\n\nasync function dispatchGlobal(type, payload) {\n  const {\n    actions = {}\n  } = global.globalStoreConfig;\n  const actionFunc = actions[type];\n  const self = this;\n  let res = {};\n  res = await dispatchActionPromise(global.emitter, { type, payload });\n  if (!actionFunc) {\n    console.warn('not found action', type, actions);\n    return Promise.resolve(res);\n  }\n  res = await actionFunc.call(self, {\n    commit: commitGlobal.bind(self),\n    dispatch: dispatchGlobal.bind(self),\n    message: global.messageManager,\n    put: function (type, ...args) {\n      const func = actions[type];\n      if (!func) {\n        throw new Error(`not found ${type} action`);\n      }\n      if (func) {\n        func.apply(self, args);\n      }\n    },\n    get state() {\n      return wrapDataInstance(global.getGlobalState());\n    },\n    get getters() {\n      return wrapDataInstance(global.getGlobalState().$getters);\n    },\n    get global() {\n      return wrapDataInstance(global.getGlobalState());\n    },\n    getRef(name) {\n      return global.getComponentRef(name);\n    },\n    select(filter) {\n      return filter(wrapDataInstance({ ...global.getGlobalState() }));\n    },\n    getState(instanceName) {\n      if (!instanceName) {\n        return wrapDataInstance(global.getGlobalState());\n      }\n      return global.getState(instanceName);\n    }\n  }, wrapDataInstance(payload));\n  // 保证结果为一个 promise\n  if (res instanceof Promise) {\n    return res;\n  }\n  return Promise.resolve(res);\n}\n\nfunction getConfigFromGlobal(global, key) {\n  const targetInstanceObj = global.getInstance(key || global.getCurrentViewId());\n  const instance = targetInstanceObj ? targetInstanceObj.store.getInstance() : {};\n  return { ...targetInstanceObj.config, instance };\n}\nfunction getConfigFromInstance(target) {\n  return {\n    mutations: target.mutations,\n    actions: target.actions,\n    instance: target.getInstance()\n  };\n}\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function createConnectHelpers(global, key, config = {}, isInstance) {\n  return {\n    commitGlobal: commitGlobal.bind(this),\n    dispatchGlobal: dispatchGlobal.bind(this),\n    commit(type, payload, innerHelper) {\n      const finalKey = key || global.getCurrentPath() || global.getCurrentViewId() || -1;\n      const { instance, mutations = {} } = global.storeInstance ? getConfigFromInstance(global) : getConfigFromGlobal(global, finalKey);\n      Object.assign(mutations, config.mutations);\n      if (!type) {\n        throw new Error(`${type} not found`);\n      }\n      if (isObject(type)) {\n        payload = type;\n        type = 'update';\n      }\n      if (isString(type) && startsWith(type, '$global:')) {\n        const realType = type.split(':').pop();\n        return commitGlobal.call(instance, realType, payload);\n      }\n      const prevState = { ...instance.data };\n      const finalMutation = mutationHandler(mutations[type], wrapDataInstance(instance.data), payload, innerHelper);\n      instance.$emitter.emitEvent('updateState', { state: finalMutation, mutation: { type, payload }, prevState });\n      // commit 的结果是一个同步行为\n      return instance.data;\n    },\n    async dispatch(type, payload) {\n      const finalKey = key || global.getCurrentPath() || global.getCurrentViewId() || -1;\n      const {\n        instance,\n        mutations = {},\n        actions = {}\n      } = global.storeInstance ? getConfigFromInstance(global) : getConfigFromGlobal(global, finalKey);\n      if (!type) {\n        throw new Error('action type not found');\n      }\n      if (isString(type) && startsWith(type, '$global:')) {\n        const realType = type.split(':').pop();\n        return dispatchGlobal.call(this, realType, payload);\n      }\n      // 获取目标 instance 的数据\n      Object.assign(mutations, config.mutations);\n      Object.assign(actions, config.actions);\n\n      const actionFunc = actions[type];\n      const self = this;\n      let res = {};\n      res = await dispatchActionPromise(instance.$emitter, { type, payload });\n      if (!actionFunc) {\n        console.warn('not found action', type, actions);\n        return Promise.resolve(res);\n      }\n      res = await actionFunc.call(self, {\n        commit: this.commit.bind(self),\n        dispatch: this.dispatch.bind(self),\n        message: global.messageManager,\n        dispatchGlobal: dispatchGlobal.bind(self),\n        commitGlobal: commitGlobal.bind(self),\n        put: function (type, ...args) {\n          const func = actions[type];\n          if (!func) {\n            throw new Error(`not found ${type} action`);\n          }\n          if (func) {\n            func.apply(self, args);\n          }\n        },\n        get state() {\n          return wrapDataInstance(instance.data, self);\n        },\n        get getters() {\n          return wrapDataInstance(instance.data.$getters, self);\n        },\n        get global() {\n          return wrapDataInstance(instance.data.$global);\n        },\n        getRef(name) {\n          return global.getComponentRef(name);\n        },\n        getState(instanceName) {\n          if (!instanceName) {\n            return wrapDataInstance(instance.data, self);\n          }\n          return global.getState(instanceName);\n        },\n        select(filter) {\n          return filter(wrapDataInstance({ ...instance.data }));\n        }\n      }, wrapDataInstance(payload));\n      // 保证结果为一个 promise\n      if (res instanceof Promise) {\n        return res;\n      }\n      return Promise.resolve(res);\n    }\n  };\n};exports.createConnectHelpers = createConnectHelpers\n// 创建 commit 和 dispatch instance\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function createHelpers(actions, mutationsObj, emitter, getInstance) {\n  const mutations = Object.assign({}, mutationsObj, innerMutation);\n  return {\n    commitGlobal: commitGlobal.bind(this),\n    dispatchGlobal: dispatchGlobal.bind(this),\n    commit(type, payload, innerHelper) {\n      if (!type) {\n        throw new Error(`not found ${type} action`);\n      }\n      if (isObject(type)) {\n        payload = type;\n        type = 'update';\n      }\n      if (isString(type) && startsWith(type, '$global:')) {\n        const realType = type.split(':').pop();\n        return commitGlobal.call(this, realType, payload);\n      }\n      const prevState = { ...this.data };\n      const finalMutation = mutationHandler(mutations[type], wrapDataInstance(this.data), payload, innerHelper);\n      // 触发更新机制\n      emitter.emitEvent('updateState', { state: finalMutation, mutation: { type, payload }, prevState });\n      // commit 的结果是一个同步行为，返回值\n      return this.data;\n    },\n    async dispatch(type, payload) {\n      const actionCache = Object.assign({}, actions, this);\n      if (!type) {\n        throw new Error('action type not found');\n      }\n      if (isString(type) && startsWith(type, '$global:')) {\n        const realType = type.split(':').pop();\n        return dispatchGlobal.call(this, realType, payload);\n      }\n      const actionFunc = actionCache[type];\n      const self = this;\n      let res = {};\n      res = await dispatchActionPromise(emitter, { type, payload });\n      if (!actionFunc) {\n        console.warn('not found action', type, actions);\n        return Promise.resolve(res);\n      }\n      res = await actionFunc.call(self, {\n        commit: this.commit.bind(self),\n        dispatch: this.dispatch.bind(self),\n        dispatchGlobal: dispatchGlobal.bind(self),\n        commitGlobal: commitGlobal.bind(self),\n        message: global.messageManager,\n        put: function (type, ...args) {\n          const func = actionCache[type];\n          if (!func) {\n            throw new Error(`not found ${type} action`);\n          }\n          if (func) {\n            func.apply(self, args);\n          }\n        },\n        get state() {\n          return wrapDataInstance(self.data, self);\n        },\n        get getters() {\n          return wrapDataInstance(self.data.$getters, self);\n        },\n        get global() {\n          return wrapDataInstance(self.data.$global);\n        },\n        getRef(name) {\n          return global.getComponentRef(name);\n        },\n        getState(instanceName) {\n          if (!instanceName) {\n            return wrapDataInstance(self.data, self);\n          }\n          return global.getState(instanceName);\n        },\n        select(filter) {\n          return filter(wrapDataInstance({ ...self.data }));\n        }\n      }, wrapDataInstance(payload));\n      // 保证结果为一个 promise\n      if (res instanceof Promise) {\n        return res;\n      }\n      return Promise.resolve(res);\n    }\n  };\n};exports.default = createHelpers\n","var __TEMP__ = require('./utils/is');var isString = __TEMP__['isString'];var isArray = __TEMP__['isArray'];var isFunc = __TEMP__['isFunc'];\nvar __TEMP__ = require('./wrapDataInstance');var wrapDataInstance = __REQUIRE_DEFAULT__(__TEMP__);\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function setDataByStateProps(mapStateToProps, data = {}, config, mapGettersToProps = [], instance, next) {\n  let gettersState = {};\n  // data 是增量\n  const finalData = next ? instance.data : data;\n  const stateToExpose = wrapDataInstance({ ...finalData });\n  const gettersToExpose = wrapDataInstance({ ...finalData.$getters });\n  const shouldUpdateKeys = Object.keys(data);\n  const ownProps = {...this.props};\n\n  if (mapGettersToProps) {\n    gettersState = mapGettersToProps.filter(d => !!d).reduce((p, v) => {\n      p[v] = gettersToExpose ? gettersToExpose[v] : (stateToExpose[v] || undefined);\n      return p;\n    }, {});\n  }\n  // 对齐 redux 的用法，第二个为 ownProps，不是很推荐，每次更新都会计算\n  // TODO: 增加记忆点,暂时开发者自己保证\n  if (isFunc(mapStateToProps)) {\n    return mapStateToProps(stateToExpose, wrapDataInstance(ownProps), gettersToExpose);\n  }\n  if (isArray(mapStateToProps)) {\n    // 必须新增部分包含这样的更新\n    const outterState = mapStateToProps\n        .filter(d => !!d && shouldUpdateKeys.includes(d))\n        .reduce((p, v) => {\n          p[v] = finalData[v];\n          return p;\n        }, {});\n    return { ...outterState, ...gettersState };\n  }\n  const outterState = Object.keys(mapStateToProps).reduce((p, v) => {\n    if (isString(mapStateToProps[v])) {\n      if (!shouldUpdateKeys.includes(mapStateToProps[v])) {\n        // 如果 diff 不包含第二次就不理睬\n        return p;\n      }\n      p[v] = finalData[mapStateToProps[v]];\n    } else {\n      p[v] = mapStateToProps[v](stateToExpose, gettersToExpose, wrapDataInstance(ownProps), stateToExpose.$global, config);\n    }\n    return p;\n  }, {});\n  return { ...outterState, ...gettersState };\n};exports.setDataByStateProps = setDataByStateProps\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function setStoreDataByState(storeData = {}, state = {}) {\n  return Object.keys(state).reduce((p, v) => {\n    p[v] = state[v];\n    return p;\n  }, storeData);\n};exports.setStoreDataByState = setStoreDataByState\n","var __TEMP__ = require('./createHelpers');var createConnectHelpers = __TEMP__['createConnectHelpers'];\nvar __TEMP__ = require('./dataTransform');var setDataByStateProps = __TEMP__['setDataByStateProps'];\nvar __TEMP__ = require('./mapHelpersToMethod');var mapActionsToMethod = __TEMP__['mapActionsToMethod'];var mapMutationsToMethod = __TEMP__['mapMutationsToMethod'];\nvar __TEMP__ = require('./utils/is');var isString = __TEMP__['isString'];\n\nvar __TEMP__ = require('./global');var global = __REQUIRE_DEFAULT__(__TEMP__);\n\nfunction getPath(link, number = 1) {\n  return isString(link) && link.split('/')[number];\n}\n\nconst defaultConfig = {\n  data: {},\n  props: {},\n  methods: {}\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function connect(options) {\n  const { mapStateToProps = [], mapGettersToProps = [], instanceName = '', namespace, data = {}, props = {} } = options;\n  return function (config = defaultConfig) {\n    config.data = config.data || {};\n    config.props = config.props || {};\n    config.methods = config.methods || {};\n    if (options.mapActionsToMethod) {\n      mapActionsToMethod(options.mapActionsToMethod, false, config.methods);\n    }\n    if (options.methods) {\n      mapMutationsToMethod(options.methods, config.methods);\n    }\n    if (options.mapMutationsToMethod) {\n      mapMutationsToMethod(options.mapMutationsToMethod, config.methods);\n    }\n    const _didMount = config.didMount;\n    const _didUnMount = config.didUnmount;\n    const key = namespace || instanceName;\n    Object.assign(config.data, data);\n    Object.assign(config.props, props);\n    return {\n      ...config,\n      methods: {\n        ...config.methods,\n        ...createConnectHelpers.call(global, global, key, config)\n      },\n      didMount() {\n        const that = this;\n        // 组件可以添加 $ref 来拿相应的实例\n        const propsRef = this.props.$ref;\n        const key = namespace || instanceName || global.getCurrentPath() || global.getCurrentViewId() || -1;\n        const targetInstanceObj = global.getInstance(key);\n        if (!targetInstanceObj && typeof _didMount === 'function') {\n          console.warn('未绑定 store');\n          _didMount.call(this);\n          return;\n        }\n        // 当前component表达\n        const componentIs = getPath(this.is, 2);\n        const currentRoute = targetInstanceObj.store.getInstance().route;\n        console.info(`${componentIs} 组件已关联 ${currentRoute}_${key} 的 store`, targetInstanceObj);\n        Object.assign(this, {\n          storeConfig: targetInstanceObj.config,\n          storeInstance: targetInstanceObj.store\n        });\n        this.$emitter = global.emitter;\n        const store = targetInstanceObj.store;\n        this.$store = store;\n        const initialData = setDataByStateProps.call(that, mapStateToProps, store.getInstance().data, config, mapGettersToProps, store.getInstance());\n        this.setData(initialData);\n        // 自动注册进 components 实例, propsRef 开发者自己保证唯一性\n        global.registerComponents(propsRef || `${getPath(currentRoute)}:${componentIs}`, this);\n        if (mapStateToProps) {\n          // store 触发的更新\n          this.licheexUpdateLisitener = store.$emitter.addListener('updateState', ({state = {}}) => {\n            const nextData = setDataByStateProps.call(that, mapStateToProps, state, config, mapGettersToProps, store.getInstance(), true);\n            const originBindViewId = this.$page.$viewId || -1;\n            const currentViewId = getCurrentPages().pop() ? getCurrentPages().pop().$viewId || -1 : -1;\n            if (originBindViewId !== currentViewId) return;\n            that.setData(nextData);\n          });\n        }\n        if (typeof _didMount === 'function') {\n          _didMount.call(this);\n        }\n      },\n      didUnmount() {\n        this.licheexUpdateLisitener && this.licheexUpdateLisitener();\n        if (typeof _didUnMount === 'function') {\n          _didUnMount.call(this);\n        }\n      }\n    };\n  };\n};exports.default = connect\n","var __TEMP__ = require('./utils/is');var isArray = __TEMP__['isArray'];var isFunc = __TEMP__['isFunc'];var isObject = __TEMP__['isObject'];\nvar __TEMP__ = require('./wrapDataInstance');var wrapDataInstance = __REQUIRE_DEFAULT__(__TEMP__);\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function mapActionsToMethod(mappers, actions, target) {\n  if (isArray(mappers)) {\n    mappers.forEach(element => {\n      // 强制不校验或校验但不通过\n      if (actions === false || actions[element]) {\n        target[element] = function(payload) {\n          if (isObject(payload)) {\n            wrapDataInstance(payload);\n          }\n          this.dispatch(element, payload);\n        };\n      }\n    });\n  } else if (isFunc(mappers)) {\n    const result = mappers(this.dispatch, this);\n    Object.assign(target, result);\n  } else {\n    Object.keys(mappers).forEach(element => {\n      if (isFunc(methodName)) {\n        target[element] = function(payload) {\n          if (isObject(payload)) {\n            wrapDataInstance(payload);\n          }\n          methodName.call(this, payload);\n        };\n        return;\n      }\n      const methodName = mappers[element];\n      if (actions === false || actions[methodName]) {\n        target[element] = function(e) {\n          const payload = e;\n          this.dispatch(methodName, payload);\n        };\n      }\n    });\n  }\n};exports.mapActionsToMethod = mapActionsToMethod;\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function mapMutationsToMethod(mappers, target) {\n  if (isArray(mappers)) {\n    mappers.forEach(element => {\n      target[element] = function(payload) {\n        if (isObject(payload)) {\n          wrapDataInstance(payload);\n        }\n        this.commit(element, payload);\n      };\n    });\n  } else if (isFunc(mappers)) {\n    const result = mappers(this.commit, this);\n    Object.assign(target, result);\n  } else {\n    Object.keys(mappers).forEach(element => {\n      const methodName = mappers[element];\n      if (isFunc(methodName)) {\n        target[element] = function(payload) {\n          if (isObject(payload)) {\n            wrapDataInstance(payload);\n          }\n          methodName.call(this, payload);\n        };\n        return;\n      }\n      target[element] = function(e) {\n        const payload = e;\n        this.commit(methodName, payload);\n      };\n    });\n  }\n};exports.mapMutationsToMethod = mapMutationsToMethod\n","var __TEMP__ = require('./global');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./storeConfigPreHandle');var configPreHandler = __REQUIRE_DEFAULT__(__TEMP__);\n\nfunction getPath(link) {\n  return link && link.split('/')[1];\n}\n// 允许空\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function GlobalStore(config = {}) {\n  configPreHandler(config);\n  global.setGlobalStoreConfig(config);\n  return function(config) {\n    const _onLoad = config.onLoad;\n    config.onLoad = function(options) {\n      global.emitter.emitEvent('updateCurrentPath', {\n        currentPath: getPath(options.path),\n        query: {}\n      });\n      _onLoad(options);\n    };\n    return config;\n  };\n};exports.default = GlobalStore;\n","var __TEMP__ = require('./utils/is');var isArray = __TEMP__['isArray'];var isFunc = __TEMP__['isFunc'];\n\nfunction shouldImmutableDecorate(f, config) {\n  if (f._shouldImmutable || f._shouldImmutable === false) {\n    return;\n  }\n  const functionString = f.toString();\n  // 当 mutation 写了 return 语句，则自己保证其 immutable，建议就使用提供的 immutable-helper\n  if (config.$useImmer || !/return /gm.test(functionString)) {\n    f._shouldImmutable = true;\n  }\n}\n\nfunction wrapMutation(config) {\n  Object.values(config).forEach(func => {\n    shouldImmutableDecorate(func, config);\n  });\n}\n\nfunction configPreHandler(config) {\n  // 防空\n  config.state = config.state || {};\n  config.mutations = config.mutations || {};\n  config.actions = config.actions || {};\n    // 给插件提供修改初始配置的能力\n  if (config.plugins) {\n    config.plugins = config.plugins.map(plugin => {\n      if (isArray(plugin)) {\n        if (isFunc(plugin[1])) {\n          plugin[1](config);\n        } else {\n          Object.assign(config, plugin[1]);\n        }\n        return plugin[0];\n      }\n      return plugin;\n    });\n  }\n  // 给 mutaiton 包装是否需要 immer 操作\n  if (config.mutations) {\n    wrapMutation(config.mutations);\n  }\n  if (config.services) {\n    const serviceRenameObj = Object.keys(config.services).reduce((p, v) => {\n      p[`$service:${v}`] = config.services[v];\n      return p;\n    }, {});\n    Object.assign(config.actions, serviceRenameObj);\n  }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = configPreHandler;\n","var __TEMP__ = require('../mapHelpersToMethod');var mapMutationsToMethod = __TEMP__['mapMutationsToMethod'];\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = function(register) {\n  const config = {\n    onLoad(data) {\n      this.dispatch('pageOnLoad', data);\n    },\n    onReady(data) {\n      this.dispatch('pageOnReady', data);\n    },\n    onShow(data) {\n      this.dispatch('pageOnShow', data);\n    },\n    onHide(data) {\n      this.dispatch('pageOnHide', data);\n    },\n    onUnload(data) {\n      this.dispatch('pageOnUnload', data);\n    }\n  };\n  mapMutationsToMethod(this.methods, config);\n  return register(config);\n};\n","\n\n\n\nvar __TEMP__ = require('./utils/is');var isObject = __TEMP__['isObject'];var isFunc = __TEMP__['isFunc'];\nvar __TEMP__ = require('./utils/obj');var get = __TEMP__['get'];\n\n\nvar __TEMP__ = require('./Observer');var Observer = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst obInstance = Observer.getInstance();\n\nlet uid = 0;\n\nclass Watcher {\n  /**\n   *\n   * @param {Page | Component} ctx 上下文环境，小程序 Page 或者 Component 实例\n   * @param {Object} options 参数\n   * @param {String} options.watchPropName 监听数据自定义属性名称\n   */\n  constructor(ctx, options = {}) {\n    const { watchPropName = '$watch' } = options;\n\n    // 执行环境\n    this.ctx = ctx;\n\n    // data数据\n    this.$data = ctx.data || {};\n\n    // $watch数据\n    this.$watch = ctx[watchPropName] || {};\n\n    // 更新函数\n    this.updateFn = ctx.setState || ctx.setData;\n\n    // watcherId\n    this.id = ++uid;\n\n    // 收集data和globalData的交集作为响应式对象\n    this.reactiveData = {};\n\n    // 初始化操作\n    this.initReactiveData();\n    this.createObserver();\n    this.setCustomWatcher();\n\n    // 收集watcher\n    obInstance.setGlobalWatcher(this);\n  }\n\n  // 初始化数据并首次更新\n  initReactiveData() {\n    const { reactiveObj } = obInstance;\n    Object.keys(this.$data).forEach((key) => {\n      if (key in reactiveObj) {\n        this.reactiveData[key] = reactiveObj[key];\n        this.update(key, reactiveObj[key]);\n      }\n    });\n  }\n\n  // 添加订阅\n  createObserver() {\n    Object.keys(this.reactiveData).forEach((key) => {\n      obInstance.onReactive(key, this);\n    });\n  }\n\n  // 初始化收集自定义watcher\n  setCustomWatcher() {\n    const watch = this.$watch;\n    /* $watch为一个对象，键是需要观察的属性名或带参数的路径，值是对应回调函数，值也可以是包含选项的对象，\n    其中选项包括 {function} handler   {boolean} deep   {boolean} immediate\n    回调函数中参数分别为新值和旧值\n    $watch: {\n      'key': function(newVal, oldVal) {},\n      'obj.key': {\n        handler: function(newVal, oldVal) {},\n        deep: true,\n        immediate: true\n      }\n    } */\n    Object.keys(watch).forEach((key) => {\n      // 记录参数路径\n      const keyArr = key.split('.');\n      let obj = this.$data;\n      for (let i = 0; i < keyArr.length - 1; i++) {\n        if (!obj) return;\n        obj = get(obj, keyArr[i]);\n      }\n      if (!obj) return;\n      const property = keyArr[keyArr.length - 1];\n      // 兼容两种回调函数的形式\n      const cb = watch[key].handler || watch[key];\n      // deep参数 支持对象/数组深度遍历\n      const deep = watch[key].deep;\n      this.reactiveWatcher(obj, property, cb, deep);\n      // immediate参数 支持立即触发回调\n      if (watch[key].immediate) this.handleCallback(cb, obj[property]);\n    });\n  }\n\n  // 响应式化自定义watcher\n  reactiveWatcher(obj, key, cb, deep) {\n    let val = obj[key];\n    // 如果需要深度监听 递归调用\n    if (isObject(val) && deep) {\n      Object.keys(val).forEach((childKey) => {\n        this.reactiveWatcher(val, childKey, cb, deep);\n      });\n    }\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: () => val,\n      set: (newVal) => {\n        if (newVal === val) return;\n        // 触发回调函数\n        this.handleCallback(cb, newVal, val);\n        val = newVal;\n        // 如果深度监听 重新监听该对象\n        if (deep) this.reactiveWatcher(obj, key, cb, deep);\n      },\n    });\n  }\n\n  // 执行自定义watcher回调\n  handleCallback(cb, newVal, oldVal) {\n    if (!isFunc(cb) || !this.ctx) return;\n    try {\n      cb.call(this.ctx, newVal, oldVal);\n    } catch (e) {\n      console.warn(`[$watch error]: callback for watcher \\n ${cb} \\n`, e);\n    }\n  }\n\n  // 移除订阅\n  removeObserver() {\n    // 移除相关依赖并释放内存\n    obInstance.removeReactive(Object.keys(this.reactiveData), this.id);\n    obInstance.removeEvent(this.id);\n    obInstance.removeWatcher(this.id);\n  }\n\n  // 更新数据和视图\n  update(key, value) {\n    if (isFunc(this.updateFn) && this.ctx) {\n      this.updateFn.call(this.ctx, { [key]: value });\n    }\n  }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Watcher;\n","const pathSeperatorRegex =\n  /\\[\\s*(['\"])(.*?)\\1\\s*\\]|^\\s*(\\w+)\\s*(?=\\.|\\[|$)|\\.\\s*(\\w*)\\s*(?=\\.|\\[|$)|\\[\\s*(-?\\d+)\\s*\\]/g;\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var isArray = exports.isArray = (objectOrArray) => Array.isArray(objectOrArray);\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var clone = exports.clone = (objectOrArray) =>\n  isArray(objectOrArray)\n    ? Array.from(objectOrArray)\n    : Object.assign({}, objectOrArray);\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var has = exports.has = (object, key) => {\n  return object != null && Object.prototype.hasOwnProperty.call(object, key);\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var get = exports.get = (root, path, defaultValue) => {\n  try {\n    if (path in root) return root[path];\n    if (Array.isArray(path)) path = \"['\" + path.join(\"']['\") + \"']\";\n    var obj = root;\n    path.replace(\n      pathSeperatorRegex,\n      function (\n        wholeMatch,\n        quotationMark,\n        quotedProp,\n        firstLevel,\n        namedProp,\n        index\n      ) {\n        obj = obj[quotedProp || firstLevel || namedProp || index];\n      }\n    );\n    return obj == undefined ? defaultValue : obj;\n  } catch (err) {\n    return defaultValue;\n  }\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var set = exports.set = (root, path, newValue) => {\n  const newRoot = clone(root);\n  if (typeof path === \"number\" || (!isArray(path) && path in newRoot)) {\n    // Just set it directly: no need to loop\n    newRoot[path] = newValue;\n    return newRoot;\n  }\n  let currentParent = newRoot;\n  let previousKey;\n  let previousKeyIsArrayIndex = false;\n  if (isArray(path)) {\n    path = \"['\" + path.join(\"']['\") + \"']\";\n  }\n  path.replace(\n    pathSeperatorRegex,\n    // @ts-ignore\n    (wholeMatch, _quotationMark, quotedProp, firstLevel, namedProp, index) => {\n      if (previousKey) {\n        // Clone (or create) the object/array that we were just at: this lets us keep it attached to its parent.\n        const previousValue = currentParent[previousKey];\n        let newValue;\n        if (previousValue) {\n          newValue = clone(previousValue);\n        } else if (previousKeyIsArrayIndex) {\n          newValue = [];\n        } else {\n          newValue = {};\n        }\n        currentParent[previousKey] = newValue;\n        // Now advance\n        currentParent = newValue;\n      }\n      previousKey = quotedProp || firstLevel || namedProp || index;\n      previousKeyIsArrayIndex = !!index;\n      // This return makes the linter happy\n      // return wholeMatch;\n    }\n  );\n  currentParent[previousKey] = newValue;\n  return newRoot;\n};\n","var __TEMP__ = require('./utils/obj');var get = __TEMP__['get'];var set = __TEMP__['set'];var has = __TEMP__['has'];\nvar __TEMP__ = require('./utils/is');var isFunc = __TEMP__['isFunc'];\n\nclass Observer {\n  constructor() {\n    // 初始化响应式对象\n    this.reactiveObj = {};\n\n    // 响应式对象集合\n    this.reactiveBus = {};\n\n    // 自定义事件集合\n    this.eventBus = {};\n\n    // 全局watcher集合\n    this.globalWatchers = [];\n  }\n\n  // 获取唯一实例\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new Observer();\n    }\n    return this.instance;\n  }\n\n  // 收集全局 watcher\n  setGlobalWatcher(obj) {\n    if (!this.isExistSameId(this.globalWatchers, obj.id)) this.globalWatchers.push(obj);\n  }\n\n  // 收集响应式数据\n  onReactive(key, obj) {\n    if (!this.reactiveBus[key]) this.reactiveBus[key] = [];\n    if (!this.isExistSameId(this.reactiveBus[key], obj.id)) this.reactiveBus[key].push(obj);\n  }\n\n  // 收集自定义事件\n  onEvent(key, callback, ctx, watcherId) {\n    if (!this.eventBus[key]) this.eventBus[key] = [];\n    if (this.isExistSameId(this.eventBus[key], watcherId)) {\n      if (console && console.warn) console.warn(`自定义事件 '${key}' 无法重复添加，请尽快调整`);\n    } else {\n      this.eventBus[key].push(this.toEventObj(watcherId, callback.bind(ctx)));\n    }\n  }\n\n  // 收集仅执行一次事件\n  once(key, callback, watcherId) {\n    // 创建一个调用后立即解绑函数\n    const wrapFanc = (args) => {\n      callback(args);\n      this.off(key, watcherId);\n    };\n    this.onEvent(key, wrapFanc, watcherId);\n  }\n\n  // 转为eventBus对象\n  toEventObj(id, callback) {\n    return {\n      id,\n      callback,\n    };\n  }\n\n  // 解绑自定义事件\n  off(key, watcherId) {\n    if (!has(this.eventBus, key)) return;\n    this.eventBus[key] = this.removeById(this.eventBus[key], watcherId);\n    this.removeEmptyArr(this.eventBus, key);\n  }\n\n  // 移除reactiveBus\n  removeReactive(watcherKeys, id) {\n    watcherKeys.forEach((key) => {\n      this.reactiveBus[key] = this.removeById(this.reactiveBus[key], id);\n      this.removeEmptyArr(this.reactiveBus, key);\n    });\n  }\n\n  // 移除eventBus\n  removeEvent(id) {\n    const eventKeys = Object.keys(this.eventBus);\n    eventKeys.forEach((key) => {\n      this.eventBus[key] = this.removeById(this.eventBus[key], id);\n      this.removeEmptyArr(this.eventBus, key);\n    });\n  }\n\n  // 移除全局watcher\n  removeWatcher(id) {\n    this.globalWatchers = this.removeById(this.globalWatchers, id);\n  }\n\n  // 触发响应式数据更新\n  emitReactive(key, value) {\n    const mergeKey = key.indexOf('.') > -1 ? key.split('.')[0] : key;\n    if (!has(this.reactiveBus, mergeKey)) return;\n    this.reactiveBus[mergeKey].forEach((obj) => {\n      if (isFunc(obj.update)) obj.update(key, value);\n    });\n  }\n\n  // 触发自定义事件更新\n  emitEvent(key, value) {\n    if (!has(this.eventBus, key)) return;\n    this.eventBus[key].forEach((obj) => {\n      if (isFunc(obj.callback)) obj.callback(value);\n    });\n  }\n\n  // 手动更新\n  handleUpdate(key, value) {\n    // key在reactiveObj中 更新reactiveObj\n    if (has(this.reactiveObj, key)) {\n      if (get(this.reactiveObj, key) !== value) {\n        set(this.reactiveObj, key, value);\n      } else {\n        this.emitReactive(key, value);\n      }\n    } else {\n      // key不在reactiveObj中 手动更新所有watcher中的$data\n      this.globalWatchers.forEach((watcher) => {\n        if (has(watcher.$data, key)) {\n          watcher.update(key, value);\n        }\n      });\n    }\n  }\n\n  // 判断数组中是否存在相同id的元素\n  isExistSameId(arr, id) {\n    if (Array.isArray(arr) && arr.length) {\n      return arr.findIndex((item) => item.id === id) > -1;\n    }\n    return false;\n  }\n\n  // 根据id删除数组中元素\n  removeById(arr, id) {\n    if (Array.isArray(arr) && arr.length) {\n      return arr.filter((item) => item.id !== id);\n    }\n    return arr;\n  }\n\n  // 删除对象中空数组的属性\n  removeEmptyArr(obj, key) {\n    if (!obj || !Array.isArray(obj[key])) return;\n    if (obj[key].length === 0) delete obj[key];\n  }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Observer;\n","var __TEMP__ = require('./array.prototype.find');\nvar __TEMP__ = require('./array.prototype.findIndex');\nvar __TEMP__ = require('./array.prototype.includes');\nvar __TEMP__ = require('./string.prototype.includes');\nvar __TEMP__ = require('./string.prototype.startsWith');\nvar __TEMP__ = require('./proxy');\n","// https://tc39.github.io/ecma262/#sec-array.prototype.find\nif (!Array.prototype.find) {\n  console.log('add polyfill find');\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function(predicate) {\n     // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      var len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      var thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      var k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n        // d. If testResult is true, return kValue.\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return undefined.\n      return undefined;\n    },\n    configurable: true,\n    writable: true\n  });\n}\n","// https://tc39.github.io/ecma262/#sec-array.prototype.findindex\nif (!Array.prototype.findIndex) {\n  Object.defineProperty(Array.prototype, 'findIndex', {\n    value: function(predicate) {\n     // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      var len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      var thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      var k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n        // d. If testResult is true, return k.\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return k;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return -1.\n      return -1;\n    },\n    configurable: true,\n    writable: true\n  });\n}\n","// https://tc39.github.io/ecma262/#sec-array.prototype.includes\nif (!Array.prototype.includes) {\n  console.log('add polyfill includes');\n  Object.defineProperty(Array.prototype, 'includes', {\n    value: function(searchElement, fromIndex) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n\n      // 1. Let O be ? ToObject(this value).\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      var len = o.length >>> 0;\n\n      // 3. If len is 0, return false.\n      if (len === 0) {\n        return false;\n      }\n\n      // 4. Let n be ? ToInteger(fromIndex).\n      //    (If fromIndex is undefined, this step produces the value 0.)\n      var n = fromIndex | 0;\n\n      // 5. If n ≥ 0, then\n      //  a. Let k be n.\n      // 6. Else n < 0,\n      //  a. Let k be len + n.\n      //  b. If k < 0, let k be 0.\n      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n      function sameValueZero(x, y) {\n        return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));\n      }\n\n      // 7. Repeat, while k < len\n      while (k < len) {\n        // a. Let elementK be the result of ? Get(O, ! ToString(k)).\n        // b. If SameValueZero(searchElement, elementK) is true, return true.\n        if (sameValueZero(o[k], searchElement)) {\n          return true;\n        }\n        // c. Increase k by 1.\n        k++;\n      }\n\n      // 8. Return false\n      return false;\n    }\n  });\n}\n","if (!String.prototype.includes) {\n  Object.defineProperty(String.prototype, 'includes', {\n    value: function(search, start) {\n      if (typeof start !== 'number') {\n        start = 0;\n      }\n\n      if (start + search.length > this.length) {\n        return false;\n      } else {\n        return this.indexOf(search, start) !== -1;\n      }\n    }\n  });\n}\n","if (!String.prototype.startsWith) {\n  String.prototype.startsWith = function(search, pos) {\n    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n  };\n}\n","function proxyPolyfill() {\n  let ProxyPolyfill;\n  /**\n   * @param {*} o\n   * @return {boolean} whether this is probably a (non-null) Object\n   */\n  function isObject(o) {\n    return o ? typeof o === \"object\" || typeof o === \"function\" : false;\n  }\n\n  function validateProto(proto) {\n    if (proto !== null && !isObject(proto)) {\n      throw new TypeError(\n        \"Object prototype may only be an Object or null: \" + proto\n      );\n    }\n  }\n\n  const $Object = Object;\n\n  // Closure assumes that `{__proto__: null} instanceof Object` is always true, hence why we check against a different name.\n  const canCreateNullProtoObjects =\n    Boolean($Object.create) || !({ __proto__: null } instanceof $Object);\n  const objectCreate =\n    $Object.create ||\n    (canCreateNullProtoObjects\n      ? function create(proto) {\n          validateProto(proto);\n          return { __proto__: proto };\n        }\n      : function create(proto) {\n          validateProto(proto);\n          if (proto === null) {\n            throw new SyntaxError(\n              \"Native Object.create is required to create objects with null prototype\"\n            );\n          }\n\n          // nb. cast to convince Closure compiler that this is a constructor\n          var T = /** @type {!Function} */ (function T() {});\n          T.prototype = proto;\n          return new T();\n        });\n\n  const noop = function () {\n    return null;\n  };\n\n  const getProto =\n    $Object.getPrototypeOf ||\n    ([].__proto__ === Array.prototype\n      ? function getPrototypeOf(O) {\n          // If O.[[Prototype]] === null, then the __proto__ accessor won't exist,\n          // as it's inherited from `Object.prototype`\n          const proto = O.__proto__;\n          return isObject(proto) ? proto : null;\n        }\n      : noop);\n\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n  ProxyPolyfill = function (target, handler) {\n    const newTarget =\n      this && this instanceof ProxyPolyfill ? this.constructor : undefined;\n    if (newTarget === undefined) {\n      throw new TypeError(\"Constructor Proxy requires 'new'\");\n    }\n\n    return ProxyCreate(target, handler);\n  };\n\n  /**\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   * @param {boolean=} allowRevocation\n   */\n  function ProxyCreate(target, handler, allowRevocation) {\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError(\n        \"Cannot create proxy with a non-object as target or handler\"\n      );\n    }\n\n    /** @param {string} trap */\n    let throwRevoked = function (trap) {};\n\n    // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n    const unsafeHandler = handler;\n    handler = { get: null, set: null, apply: null, construct: null };\n    for (let k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError(`Proxy polyfill does not support trap '${k}'`);\n      }\n      handler[k] = unsafeHandler[k];\n    }\n    if (typeof unsafeHandler === \"function\") {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    }\n\n    // Define proxy as an object that extends target.[[Prototype]],\n    // or a Function (if either it's callable, or apply is set).\n    const proto = getProto(target); // can return null in old browsers\n    let proxy;\n    let isMethod = false;\n    let isArray = false;\n    if (typeof target === \"function\") {\n      /** @constructor */\n      proxy = function ProxyPolyfill() {\n        const usingNew = this && this.constructor === proxy;\n        const args = Array.prototype.slice.call(arguments);\n        throwRevoked(usingNew ? \"construct\" : \"apply\");\n\n        // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n        if (usingNew && handler[\"construct\"]) {\n          return handler[\"construct\"].call(this, target, args);\n        } else if (!usingNew && handler.apply) {\n          return handler[\"apply\"](target, this, args);\n        }\n\n        // since the target was a function, fallback to calling it directly.\n        if (usingNew) {\n          // inspired by answers to https://stackoverflow.com/q/1606797\n          args.unshift(target); // pass class as first arg to constructor, although irrelevant\n          // nb. cast to convince Closure compiler that this is a constructor\n          const f = /** @type {!Function} */ (target.bind.apply(target, args));\n          return new f();\n        }\n        return target.apply(this, args);\n      };\n      isMethod = true;\n    } else if (target instanceof Array) {\n      proxy = [];\n      isArray = true;\n    } else {\n      proxy =\n        canCreateNullProtoObjects || proto !== null ? objectCreate(proto) : {};\n    }\n\n    // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n    const getter = handler.get\n      ? function (prop) {\n          throwRevoked(\"get\");\n          return handler.get(this, prop, proxy);\n        }\n      : function (prop) {\n          throwRevoked(\"get\");\n          return this[prop];\n        };\n    const setter = handler.set\n      ? function (prop, value) {\n          throwRevoked(\"set\");\n          const status = handler.set(this, prop, value, proxy);\n          // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n          // if (!status) {\n          // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n          // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n          // }\n        }\n      : function (prop, value) {\n          throwRevoked(\"set\");\n          this[prop] = value;\n        };\n\n    // Clone direct properties (i.e., not part of a prototype).\n    const propertyNames = $Object.getOwnPropertyNames(target);\n    const propertyMap = {};\n    propertyNames.forEach(function (prop) {\n      if ((isMethod || isArray) && prop in proxy) {\n        return; // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n      const real = $Object.getOwnPropertyDescriptor(target, prop);\n      const desc = {\n        enumerable: Boolean(real.enumerable),\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop),\n      };\n      $Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    });\n\n    // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n    let prototypeOk = true;\n    if (isMethod || isArray) {\n      // Arrays and methods are special: above, we instantiate boring versions of these then swap\n      // our their prototype later. So we only need to use setPrototypeOf in these cases. Some old\n      // engines support `Object.getPrototypeOf` but not `Object.setPrototypeOf`.\n      const setProto =\n        $Object.setPrototypeOf ||\n        ([].__proto__ === Array.prototype\n          ? function setPrototypeOf(O, proto) {\n              validateProto(proto);\n              O.__proto__ = proto;\n              return O;\n            }\n          : noop);\n      if (!(proto && setProto(proxy, proto))) {\n        prototypeOk = false;\n      }\n    }\n    if (handler.get || !prototypeOk) {\n      for (let k in target) {\n        if (propertyMap[k]) {\n          continue;\n        }\n        $Object.defineProperty(proxy, k, { get: getter.bind(target, k) });\n      }\n    }\n\n    // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n    $Object.seal(target);\n    $Object.seal(proxy);\n\n    return allowRevocation\n      ? {\n          proxy: proxy,\n          revoke: function () {\n            /** @suppress {checkTypes} */\n            target = null; // clear ref\n            throwRevoked = function (trap) {\n              throw new TypeError(\n                `Cannot perform '${trap}' on a proxy that has been revoked`\n              );\n            };\n          },\n        }\n      : proxy;\n  }\n\n  ProxyPolyfill.revocable = function (target, handler) {\n    return ProxyCreate(target, handler, true);\n  };\n\n  return ProxyPolyfill;\n}\n\nif (!Proxy) {\n  // Export the Proxy polyfill as a global.\n  // This is needed for users that use the polyfill as a module.\n  global.Proxy = new proxyPolyfill();\n}"]}